<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浙江大傻屌&#39;s Blog</title>
  
  <subtitle>谁说我们一定要走别人的路。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zjdx1998.ml/"/>
  <updated>2018-06-18T11:35:22.937Z</updated>
  <id>http://www.zjdx1998.ml/</id>
  
  <author>
    <name>Jerome</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>离散数学期末复习</title>
    <link href="http://www.zjdx1998.ml/2018/06/05/discretemathfinalreview/"/>
    <id>http://www.zjdx1998.ml/2018/06/05/discretemathfinalreview/</id>
    <published>2018-06-05T02:57:16.000Z</published>
    <updated>2018-06-18T11:35:22.937Z</updated>
    
    <content type="html"><![CDATA[<ul><li>考试结构<blockquote><p>10道选择题(含多选,但答案不超过两个)20分<br>3道证明题来自于集合论和代数结构（重难点)</p></blockquote></li></ul><center> <font size="7"> 数理逻辑 </font> </center><h1 id="命题逻辑的基本概念"><a href="#命题逻辑的基本概念" class="headerlink" title="命题逻辑的基本概念"></a>命题逻辑的基本概念</h1><h2 id="命题与联结词"><a href="#命题与联结词" class="headerlink" title="命题与联结词"></a>命题与联结词</h2><h3 id="命题-Proposition"><a href="#命题-Proposition" class="headerlink" title="命题(Proposition)"></a>命题(Proposition)</h3><ul><li>概念：具有唯一真值的陈述句</li><li>唯一性：或真或假但不能两者都是的</li><li>命题所用符号：常用小写２６个英文字母</li><li>经典例子<ul><li>$x=3$ ×</li><li>我现在说假话 × （悖论)</li><li>请不要吸烟! ×(祈使句)</li><li>这朵花真美丽啊！ （感叹句)</li></ul></li><li>悖论:既不能为真，也不能为假的陈述句称作 <strong>悖论</strong>。</li><li>注<blockquote><p>命题是陈述句，陈述句不一定是命题<br>命题有唯一真值，但真值可能受范围、时空、环境、判断标准、认识程度限制，一时无法确定</p></blockquote></li></ul><p>命题分类</p><ul><li>简单命题：不能被分解成更简单的命题</li><li>复合命题：简单命题+联结词(Connective)</li></ul><h3 id="联结词-Connective"><a href="#联结词-Connective" class="headerlink" title="联结词(Connective)"></a>联结词(Connective)</h3><ul><li><p>否定联结词(Negation Connective)</p><ul><li>符号¬,读作“非”，“否定”</li><li>定义：命题 p<ul><li>p的否定式：复合命题“p的否定”（“非p”）</li><li>符号：$\neg$ p (符号$\neg$称作否定联结词)</li><li>$\neg$ p为真当且仅当p为假</li></ul></li><li>例子<ul><li>今天没有天晴  $\neg$p：今天天晴</li></ul></li></ul></li><li><p>合取联结词(Conjunctive Connective)</p><ul><li>符号$\wedge$,读作“合取”</li><li>定义：命题 p，q<ul><li>p与q的合取式：复合命题“p并且q”</li><li>符号： $p \wedge q$ (符号$\wedge$称作合取联结词)</li><li>p$\wedge$q为真当且仅当p和q同时为真</li></ul></li><li>例子<ul><li>王华的成绩很好并且品德很好 $p \wedge q$<br>p：王华的成绩很好<br>q：王华的品德很好</li></ul></li></ul></li><li><p>析取联结词(Disjunctive Connective)</p><ul><li>符号$\lor$,读作“析取”</li><li>定义：命题 p，q<ul><li>p与q的析取式：复合命题“p或q”</li><li>符号：$p \lor q$(符号$\lor$称作析取联结词)</li><li>p$\lor$q为假当且仅当p和q同时为假</li></ul></li><li>例子<ul><li>小李是学数学或者计算机科学p$\lor$q<br>p：小李是学数学<br>q：小李是学计算机科学</li></ul></li></ul></li><li>析取联结词 排斥或<ul><li>符号 $\oplus$</li><li>定义：命题 p，q<br>  符号：p$\oplus$q<br>  等价于(p$\wedge\neg$q)$\lor$($\neg p\wedge q$)<br>  p$\oplus$q为假当且仅当p和q同时为假或同时为真</li><li>例子：<br>  小李在教室看书或在图书馆上网<br>  小李在看书或者听音乐 </li></ul></li><li><p>蕴涵联结词(Implication Connective)</p><ul><li>符号$\to$,读作“如果…则…”、“蕴涵”</li><li>定义：命题 p，q<br>  p与q的蕴涵式：复合命题“如果p，则q”<br>  符号：$p \to q$(符号$\to$称作蕴涵联结词)<br>  $p \to q$为假当且仅当p为真，q为假</li><li>例子<br>  如果天下雨，那么地下湿 $p \to q$<br>  p：天下雨 , q：地下湿</li><li>注<ul><li>q是p的必要条件</li><li>p为假，$p \to q$永远为真</li><li>给定命题$p \to q$<ul><li>它的逆命题$q \to p$</li><li>它的反命题$\neg p\to\neg q$</li><li>它的逆反命题 $\neg q \to\neg p$</li></ul></li><li>各种命题关系<ul><li>$ p \to q \Leftrightarrow \neg q\to \neg p$</li><li>$ q \to p \Leftrightarrow \neg p\to \neg q$</li></ul></li></ul></li></ul></li><li><p>等价联结词(Equivalence Connective)</p><ul><li>符号$\leftrightarrow$,读作“当且仅当”</li><li>定义：命题 p，q<br>  p与q的等价式：复合命题“p当且仅当q”<br>  符号：$p \leftrightarrow q$(符号称作等价联结词)<br>  $p \leftrightarrow q$为真当且仅当p与q真值相同</li><li>例子<br>  当且仅当2+3=5，才有2是素数  $p \leftrightarrow q$<br>  p： 2+3=5 , q： 2是素数</li></ul></li><li>优先级<ul><li>联结词：$\neg \wedge \lor \to \leftrightarrow$</li><li>同括号最优先   </li><li>同一优先级：从左到右</li><li>例子：求于命题$\neg p\lor q\to r$含义相同的是$ ((\neg p)\lor q)\to q $</li></ul></li></ul><style>table th:first-of-type {    width: 100px;}</style> <table><thead><tr><th>p</th><th>q</th><th>$p \wedge q$</th><th>$p \lor q$</th><th>$p \oplus q$</th><th>$p \to q$</th><th>$p \leftrightarrow q$</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>F</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr></tbody></table><h2 id="命题公式及其赋值"><a href="#命题公式及其赋值" class="headerlink" title="命题公式及其赋值"></a>命题公式及其赋值</h2><h3 id="命题公式"><a href="#命题公式" class="headerlink" title="命题公式"></a>命题公式</h3><ul><li>命题常项(Propositional Constant)：简单命题</li><li>命题变项(Propositional Variable)：表示命题的变量<ul><li>真值可以变化的陈述句</li><li>命题变项不是命题</li><li>命题变项用确定命题代入才能确定真值</li><li>命题所用符号：常用小写２６个英文字母</li><li>命题变量不同于代数式的变量<ul><li>如：x+y&gt;4的x，y不是命题变量</li></ul></li></ul></li><li>合式公式（命题公式）(Statement Formula)的递归定义：<ol><li>单个命题常项或命题变项是合式公式（原子命题公式）</li><li>A为合式公式，则$\neg A$是合式公式</li><li>A , B为合式公式,则（$A \wedge B$），（ $A \lor B$），<br>（$A \to B$）,（$A \leftrightarrow B$）为合式公式</li><li>有限次应用1-3形成的符号串为合式公式</li></ol><ul><li>子公式B：给定合式公式A<ul><li>B是A的一部分</li><li>B是合式公式</li></ul></li><li>符号说明<ul><li>大写字母A，B表示合式公式</li><li>公式简写法则：<ul><li>公式最外层括号可以省略<br>*（$\neg$ A）的括号可以省略</li><li>根据运算符优先级省略括号</li><li>省略括号不能影响公式解释</li></ul></li></ul></li></ul></li><li>公式层次(Level)<ul><li>若公式A是单个的命题变元，则称A为0层合式 </li><li>称公式A是$n+1(n≥0)$层公式是指下面情况之一：<ul><li>A＝ ¬B，B是n层公式</li><li>A＝$B \wedge C$，其中B，C分别为i层和j层公式，且n＝max(i,j)</li><li>A＝$B ∨ C$ ，其中B，C的层次及n同(b)</li><li>A＝$B \to C$ ，其中B，C的层次及n同(b)</li><li>A＝$B ↔ C$ ，其中B，C的层次及n同(b)</li></ul></li><li>若公式A的层次为k，则称A是k层公式</li><li>注:层次≠联结词数</li></ul></li></ul><h3 id="命题公式的赋值"><a href="#命题公式的赋值" class="headerlink" title="命题公式的赋值"></a>命题公式的赋值</h3><ul><li><p>设$p_1,p_2,\cdots,p_n$是出现在公式$A$中的全部命题变项，给$p_1,p_2,\cdots,p_n$各指定一个真值，称为对$A$的一个 <em>赋值</em>或 <em>解释</em> 。使$A$为1的一组值称为 <em>成真赋值</em> , 使$A$为0的一组值称为 <em>成假赋值</em> 。</p></li><li><p>将命题公式A在所有赋值下取值情况列成表，称作A的真值表。构造方式：</p><ul><li>找出A中命题变项：$p_1,p_2,\cdots,p_n$</li><li>列出$2^n$个赋值（2进制加法形式）</li><li>从低到高写成公式各个层次</li><li>各个赋值：计算各层的真值</li></ul></li><li><p>设A为任一命题公式</p><ul><li>重言式(永真式)(Tautology)：v(A)=T，对任意v</li><li>矛盾式(永假式)(Contradiction) ：v(A)=F，对任意v</li><li>可满足式(Satisfiable) ：v(A)=T，对某个v</li><li>关系<br>  重言式是可满足式，反之不一定成立</li><li>真值表判断<ul><li>重言式：真值表最后一列全为T</li><li>矛盾式：真值表最后一列全为F</li><li>可满足式：真值表最后一列至少一个T</li></ul></li></ul></li></ul><h2 id="考试要点"><a href="#考试要点" class="headerlink" title="考试要点"></a>考试要点</h2><ul><li>主要内容<blockquote><p>命题、真值、简单命题与复合命题、命题符号化<br>联结词及复合命题符号化<br>命题公式及层次<br>公式的类型<br>真值表及应用</p></blockquote></li><li>基本要求<blockquote><p>深刻理解各联结词的逻辑关系, 熟练地将命题符号化<br>会求复合命题的真值<br>深刻理解合式公式及重言式、矛盾式、可满足式等<br>熟练地求公式的真值表，并用它求公式的成真赋值与成假赋值及判断公式类型</p></blockquote></li></ul><h1 id="命题逻辑等值演算"><a href="#命题逻辑等值演算" class="headerlink" title="命题逻辑等值演算"></a>命题逻辑等值演算</h1><ul><li>主要内容：<ul><li>等值式与基本的等值式</li><li>等值演算与置换规则</li><li>析取范式与合取范式，主析取范式与主合取范式</li><li>联结词完备集(本次不作要求)</li></ul></li><li>本章与其他各章的联系<ul><li>是第一章的抽象与延伸</li><li>是后续各章的先行准备</li></ul></li></ul><h2 id="等值式"><a href="#等值式" class="headerlink" title="等值式"></a>等值式</h2><ul><li>定义:若等价式$A \leftrightarrow B$是重言式，则称A与B等值，记作$A \Leftrightarrow B$，并称$A \Leftrightarrow B$是等值式(Equivalent Expression)<ul><li>说明<ul><li>定义中，A, B, $\Leftrightarrow$均为元语言符号</li><li>A或B中可能有哑元出现.<br>例如，在($p \to q$) $ \Leftrightarrow $ (($\neg p \lor q$)$ \lor $ ($\neg r\wedge r$))中，r为左边公式的哑元. </li><li>哑元：设公式A，B共含有命题变项$p_1,p_2,\cdots,p_n$，而A或者B不全含这些命题变项，比如A中不含$p_i，p_{(i+1)}$等等，那么这些命题就是公式A的哑元。</li><li>用真值表可验证两个公式是否等值</li></ul></li></ul></li><li><p>命题</p><blockquote><p>设A是一个命题公式，含有命题变项$p_1 , p_2 ,\cdots,p_n$，又设$A_1，A_2，…，A_n$是任意的命题公式. 对每个i（$i=1,2,\cdots,n$），把$p_i$在A中的所有出现都替换成$A_i$，所得到的新命题公式记作B. 那么，如果A是重言式，则B也是重言式.</p></blockquote></li><li><p>等值式模式</p><ol><li><strong>双重否定律</strong> $A \Leftrightarrow \neg\neg A$</li><li><strong>幂等律</strong> $A \Leftrightarrow A \lor A , A\Leftrightarrow A \wedge A $</li><li>交换律 $A \wedge B \Leftrightarrow B \wedge A , A \lor B \Leftrightarrow B \lor A$</li><li><strong>结合律</strong> $(A \lor B) \lor C\Leftrightarrow A \lor (B \lor C)  (A \wedge B) \wedge C\Leftrightarrow A \wedge (B \wedge C)$</li><li><strong>分配律</strong>  $ (A \lor B) \lor C\Leftrightarrow A \lor (B \lor C)\qquad<br>(A \wedge B) \wedge C\Leftrightarrow A \wedge (B \wedge C)$</li><li><strong>德摩根律</strong> $\neg(A \lor B) \Leftrightarrow \neg A\wedge\neg B , \neg(A \wedge B) \Leftrightarrow \neg A\lor\neg B$</li><li><strong>吸收律</strong> $A \lor (A \wedge B) \Leftrightarrow A , A \wedge (A \lor B) \Leftrightarrow A$</li><li>零律 $A \lor 1 \Leftrightarrow 1 , A \wedge 0 \Leftrightarrow 0$</li><li><strong>同一律</strong> $A \lor 0 \Leftrightarrow A , A \wedge 1 \Leftrightarrow A$</li><li>排中律 $A \lor\neg A \Leftrightarrow 1$</li><li>矛盾律 $A \wedge\neg A \Leftrightarrow 0$</li><li><strong>蕴含等值式</strong> $A \to B \Leftrightarrow \neg A \lor B$ </li><li>等价等值式 $A \leftrightarrow B \Leftrightarrow (A \to B)\wedge(B \to A)$</li><li><strong>假言易位</strong> $A \to B \Leftrightarrow \neg B \to \neg A$</li><li>等价否定等值律 $A \leftrightarrow B \Leftrightarrow \neg A \leftrightarrow \neg B$</li><li><strong>归谬论</strong> $(A \to B)\wedge(A \to \neg B)\Leftrightarrow\neg A$</li></ol></li><li><p>等值演算(Equivalent Calculation)：由已知的等值式推演出另外一些等值式的过程</p></li><li><p>置换规则(Replacement Rule)：设φ(A)是含公式A的命题公式， φ(B)是用公式B置换了φ(A)中所有A后得到的命题公式，若$A \Leftrightarrow B$ ，则$φ(A) \Leftrightarrow φ(B)$ </p><ul><li>说明：<ul><li>等值演算过程中遵循的重要规则</li><li>一个命题公式A，经多次置换，所得到的新公式与原公式等价</li></ul></li></ul></li></ul><h2 id="析取范式与合取范式"><a href="#析取范式与合取范式" class="headerlink" title="析取范式与合取范式"></a>析取范式与合取范式</h2><ul><li>析取式、合取式定义<ul><li>文字(literal): 命题变项及其否定</li><li>简单析取式(Simple Disjunction):仅由有限个文字构成的析取式</li><li>简单合取式(Simple Conjunction):仅由有限个文字构成的合取式</li></ul></li><li>定理:<blockquote><p>1)一个简单析取式是永真式当且仅当它同时含某个命题变元及它的否定式<br>2)一个简单合取式是永假式当且仅当它同时含某个命题变元及它的否定式</p></blockquote></li><li>定义<ul><li>析取范式(Disjunctive Normal Form):由有限个简单合取式构成的析取式</li><li>合取范式(Conjunctive Normal Form):由有限个简单析取式构成的合取式</li><li>析取范式与合取范式统称为范式(Normal Form)</li></ul></li><li><p>定理</p><blockquote><p>$A_i$ 简单合取式, $A_1 \lor \cdots \lor A_n \Leftrightarrow F$ 当且仅当 $A_i \Leftrightarrow F$，对任意$A_i$<br>$A_i$ 简单析取式, $A_1 \wedge \cdots \wedge A_n \Leftrightarrow T$ 当且仅当 $A_i \Leftrightarrow T$，对任意$A_i$</p></blockquote></li><li><p>范式存在定理: 任意命题公式都存在着与之等值的析取范式与合取范式</p><ul><li>方法： <ul><li>步骤一：消去“$\to$”、“$\leftrightarrow$”联结词</li><li>步骤二：消去双重否定符，内移否定符（双重否定律、德摩根律）</li><li>步骤三：使用分配律</li></ul></li></ul><p>极小项 Miniterm (极大项 Maxterm):含有n个命题变项的简单合取式 (简单析取式)，并满足</p><blockquote><ul><li>每个命题变元和它的否定式不同时出现，而二者之一必出现且仅出现一次</li><li>第i个命题变项或它的否定式出现在从左算起的第i位上(若无角标，则按字典顺序排列)<blockquote><p>若有ｎ个命题变项，则有$2^n$个极小项（极大项）<br>如果我们把不带否定符的命题变项取成1，带否定符的命题变项取成0，那么每一个极小项都对应一个二进制数，因而也对应一个十进制数<br>极小项的编码:对应成真赋值,如 $p \wedge q \wedge r$对应$TTT , m_7$<br>极大项的编码:对应成假赋值,如 $\neg p \lor \neg q \lor \neg r$对应$TTT , M_7$</p></blockquote></li></ul></blockquote><p>定理:设$m_i$和$M_i$是命题变元$p_1 , p_2 ,\cdots,p_n$形成的极小项和极大项,则:</p><blockquote><ol><li>$m_i \wedge m_j \Leftrightarrow F (i \neq j)$(一个赋值不可能使两个均为真)</li><li>$M_i \lor M_j \Leftrightarrow T (i \neq j) $（一个赋值不可能使两个均为假）</li><li>$\neg m_i \Leftrightarrow M_i , \neg M_i \Leftrightarrow m_i$</li></ol></blockquote></li><li><p>主范式</p><blockquote><ul><li><strong>主析取范式</strong> Principal Disjunctive Normal Form ：由n个命题变项构成的析取范式中所有的简单合取式都是极小项</li><li><strong>主合取范式</strong> Principal Conjunctive Normal Form : 由n个命题变项构成的合取范式中所有的简单析取式都是极大项</li><li>定理: 任何命题公式都存在着与其等值的主析取范式和主合取范式，并且是唯一的。</li></ul></blockquote><ul><li>一个公式的主析取范式即为令此公式的真值为T的指派所对应的极小项的析取。</li><li>一个命题公式的真值表是唯一的，因此一个命题公式的主析取范式也是唯一的</li><li>任何一个命题公式都可求得它的主合取范式</li><li>一个命题公式的主合取范式是唯一的</li><li>在真值表中，令命题公式的真值为“F”的指派就对应其主合取范式的一个极大项</li><li>重言式的主合取范式不含任何极大项，为1. </li><li>矛盾式的主析取范式不含任何极小项, 为0.  </li></ul></li><li>主析（合）取范式的用途讨论：<ul><li>求公式的成真与成假赋值</li><li>判断公式类型</li><li>判断两个命题公式是否等值</li><li>应用主析（合）取范式分析和解决实际问题</li></ul></li></ul><h2 id="联结词的完备集"><a href="#联结词的完备集" class="headerlink" title="联结词的完备集"></a>联结词的完备集</h2><ul><li>“与非”联结词：<ul><li>符号 $ \uparrow $</li><li>($p \uparrow q$)读作：“p与q的否定”</li><li><strong>$p \uparrow q \Leftrightarrow \neg (p \wedge q)$</strong></li></ul></li><li>“或非”联结词：<ul><li>符号：“↓”　</li><li>($p \downarrow q$)读作：“p或q的否定”　 </li><li><strong>($p \downarrow q) \Leftrightarrow \neg(p \lor q) $</strong></li></ul></li><li>真值函数F(Truth Function): {$0,1$}$^n \to${$0,1$}</li><li>联结词完备集S(Complete Set of Connectives): <ul><li>S是一个联结词集合</li><li>每一个真值函数都可以由仅含S中的联结词构成的公式表示</li><li><blockquote><p>定理: $S =\lbrace\neg,\wedge,\lor\rbrace$是联结词完备集<br>推论: $S =\lbrace\wedge,\neg \rbrace$是联结词完备集<br>$S = \lbrace\uparrow\rbrace , \lbrace\downarrow\rbrace$是联结词完备集。</p></blockquote></li></ul></li></ul><h2 id="考试要点-1"><a href="#考试要点-1" class="headerlink" title="考试要点"></a>考试要点</h2><ul><li>主要内容<ul><li>等值式与等值演算</li><li>基本等值式（16组，24个公式）</li><li>主析取范式与主合取范式</li><li>联结词完备集</li></ul></li><li>具体要求<blockquote><p>深刻理解等值式的概念<br>  牢记基本等值式的名称及它们的内容<br>  熟练地应用基本等值式及置换规则进行等值演算<br>  理解文字、简单析取式、简单合取式、析取范式、合取范式的概念<br>  深刻理解极小项、极大项的概念、名称及下角标与成真、成假赋值的关系<br>  熟练掌握求主范式的方法（等值演算、真值表等）<br>  会用主范式求公式的成真赋值、成假赋值、判断公式的类型、判断两个公式是否等值<br>  会将公式等值地化成指定联结词完备集中的公式<br>  会用命题逻辑的概念及运算解决简单的应用问题</p></blockquote></li><li>解决实际应用问题步骤<ol><li>设简单命题并符号化</li><li>用复合命题描述各条件</li><li>写出由复合命题组成的合取式</li><li>将合取式化成主范式</li><li>求成真赋值, 并做出解释和结论</li></ol></li></ul><h1 id="命题逻辑的推理理论"><a href="#命题逻辑的推理理论" class="headerlink" title="命题逻辑的推理理论"></a>命题逻辑的推理理论</h1><ul><li>主要内容<ul><li>推理的形式结构</li><li>自然推理系统P</li></ul></li><li>本章与其他各章的联系<ul><li>本章是第五章的特殊情况和先行准备<!--- vdash models nvdash ---></li></ul></li></ul><h2 id="推理的形式结构"><a href="#推理的形式结构" class="headerlink" title="推理的形式结构"></a>推理的形式结构</h2><ul><li>推理 (Inference) —— 从前提出发推出结论的思维过程</li><li>证明 (Proof) —— 描述推理正确或错误的过程 </li><li>推理的形式结构<ul><li>前提：$A_1,\cdots,A_k$</li><li>结论：$B$</li><li>推理的形式结构： $A_1\wedge\cdots\wedge A_k \to B$</li><li>设$\Gamma = \lbrace A_1,\cdots,A_k\rbrace $, 则记前提$\Gamma$推出$B$的推理为$\Gamma\vdash B$为推理的形式结构。</li><li>当推理正确，则记为$\Gamma\models B$</li></ul></li><li><p>逻辑(语义)蕴涵(Logical Entailment)：给定$A_1,\cdots,A_k$和B</p><ul><li>对任意赋值v:<ul><li>如果$v(A_i)=T$,则$v(B)=T$</li><li>或者存在$A_j$，使得$v(A_j)=F$</li></ul></li><li>称由前提$A_1,\cdots,A_k$ 推出结论B的推理是有效的</li><li>符号：$\lbrace A_1,\cdots,A_k\rbrace$ $ \models B$</li><li>注意: 推理正确不能保证结论一定正确</li><li>定理 $\lbrace A_1,\cdots,A_k\rbrace$ $\models B$ 当且仅当 $A_1\wedge\cdots\wedge A_k \to B$ 为重言式</li><li>蕴涵元符号: $\Rightarrow$</li><li>$A_1,\cdots,A_k \Rightarrow B$ 代表$\lbrace A_1,\cdots,A_k\rbrace$ $\models B$</li></ul></li><li><p>推理定律</p></li></ul><table><thead><tr><th>序号</th><th>公式</th><th>名称</th></tr></thead><tbody><tr><td>1</td><td>$A\Rightarrow(A \lor B)$</td><td>附加律</td></tr><tr><td>2</td><td>$(A \wedge B) \Rightarrow A$</td><td>化简律</td></tr><tr><td>3</td><td>$(A \to B)\wedge A \Rightarrow B$</td><td>假言推理</td></tr><tr><td>4</td><td>$(A \to B)\wedge \neg B \Rightarrow \neg A$</td><td>拒取式</td></tr><tr><td>5</td><td>$(A \lor B)\wedge\neg B \Rightarrow A$</td><td>析取三段论</td></tr><tr><td>6</td><td>$(A \to B)\wedge(B \to C)\Rightarrow(A \to C)$</td><td>假言三段论</td></tr><tr><td>7</td><td>$(A \leftrightarrow B)\wedge(B \leftrightarrow C)\Rightarrow(A \leftrightarrow C)$</td><td>等价三段论</td></tr><tr><td>8.1</td><td>$(A \to B)\wedge(C \to D)\wedge(A \lor C)\Rightarrow(B \lor D)$</td><td>构造性二难</td></tr><tr><td>8.2</td><td>$(A \to B)\wedge(\neg A \to B) \Rightarrow B$</td><td>构造性二难（特殊）</td></tr><tr><td>9</td><td>$(A \to B)\wedge(C \to D)\wedge(\neg B \lor \neg D)\Rightarrow(\neg A \lor \neg C)$</td><td>破坏性二难</td></tr></tbody></table><h2 id="自然推理系统P"><a href="#自然推理系统P" class="headerlink" title="自然推理系统P"></a>自然推理系统P</h2><ul><li>自然演绎推理：从一组已知为真的事实出发，直接运用经典逻辑推理规则推出结论的过程</li><li>一个形式系统 I (Formal System) 由下面四个部分组成：<br>(1)  非空的字母表，记作 A(I).<br>(2)  A(I) 中符号构造的合式公式集，记作 E(I).<br>(3)  E(I) 中一些特殊的公式组成的公理集，记作 $A_X(I)$.<br>(4)  推理规则集，记作 R(I).<br>  记$I=&lt;A(I),E(I),A_X(I),R(I)&gt;$, 其中$&lt;A(I),E(I)&gt;$是 I 的 <em>形式语言系统</em>, $&lt;A_X(I),R(I)&gt;$ 是 $I$ 的形式演算系统.</li><li>自然推理系统 P (Natural Deduction System)定义如下:<ul><li>字母表<br>(1)  命题变项符号：$p, q, r, …, p_i, q_i, r_i,\cdots$<br>(2)  联结词符号：$\neg,\wedge,\lor,\to,\leftrightarrow$<br>(3)  括号与逗号：(, ), ，</li><li>合式公式</li><li>推理规则<br>(1)  前提引入规则<br>(2)  结论引入规则<br>(3)  置换规则<br>(4)  9条推理定律和结论引入可得（4）~（12）</li></ul></li><li>构造证明方法<ul><li>附加前提证明法<br>  $(A_1,\cdots,A_k) \to (A \to B)$ 转化为 $A_1,A_2,\cdots,A_k,A\vdash B$</li><li>归谬法<br>  $(A_1\wedge\cdots\wedge A_k) \to B$ 转化为 $(A_1\wedge\cdots\wedge A_k)\wedge\neg B$为矛盾式</li></ul></li></ul><h2 id="考试要点-2"><a href="#考试要点-2" class="headerlink" title="考试要点"></a>考试要点</h2><ul><li>主要内容<ul><li>推理的形式结构</li><li>判断推理是否正确的方法<br>   真值表法<br>   等值演算法<br>   主析取范式法</li><li>推理定律</li><li>自然推理系统P</li><li>构造推理证明的方法<pre><code>直接证明法附加前提证明法归谬法(反证法)</code></pre></li></ul></li><li>基本要求<ul><li>理解并记住推理形式结构的两种形式：<ol><li>$A_1\wedge\cdots\wedge A_k \to B$</li><li>前提：$A_1,\cdots,A_k$<br>结论：$B$</li></ol></li><li>熟练掌握判断推理是否正确的不同方法（如真值表法、等值演算法、主析取范式法等）</li><li>牢记 P 系统中各条推理规则</li><li>熟练掌握构造证明的直接证明法、附加前提证明法和归谬法</li><li>会解决实际中的简单推理问题</li></ul></li></ul><h1 id="一阶逻辑基本概念"><a href="#一阶逻辑基本概念" class="headerlink" title="一阶逻辑基本概念"></a>一阶逻辑基本概念</h1><ul><li>本章的主要内容<br>  一阶逻辑命题符号化<br>  一阶逻辑公式、解释及分类</li><li>本章与其他章的联系<br>  克服命题逻辑的局限性<br>  是第五章的先行准备</li></ul><h2 id="一阶逻辑命题符号化"><a href="#一阶逻辑命题符号化" class="headerlink" title="一阶逻辑命题符号化"></a>一阶逻辑命题符号化</h2><ul><li>命题逻辑的表示能力缺陷<ul><li>命题演算的基本单元为简单命题</li><li>不能研究命题的结构、成分和内部逻辑的特征</li><li>不能表达二个原子命题所具有的共同特征，无法处理一些简单又常见的推理</li></ul></li><li>个体词（Individual Term）：研究对象中独立存在的具体或抽象的个体<ul><li>个体常项：具体或特定的个体词<ul><li>南京，东南大学，1，2</li></ul></li><li>个体变项：抽象或泛指的个体词<ul><li>x,y,z </li><li>取值范围称为个体域或论域</li></ul></li><li>空集不能作为论域</li><li>全总个体域：宇宙间一切事物</li></ul></li><li>谓词（Predicate）：刻画个体词性质及个体词之间的关系的词<ul><li>谓词常项：具体性质或关系的谓词<ul><li>F(a,b)：小王和小李是同学</li><li>G(x)：x是有理数</li></ul></li><li>谓词变项：抽象或泛指的性质或关系的谓词<ul><li>L(x,y)：x,y具有关系L</li></ul></li></ul></li><li>n元谓词$P(x_1,…,x_n)$<ul><li>$P(x_1,…,x_n)$: $D^n \to \lbrace F,T\rbrace$，D为个体域</li><li>不带个体变项的谓词为0元谓词。当为谓词常项时， 0元谓词即命题</li></ul></li><li>量词（Quantifier）：表示个体常项或变项之间数量关系的词</li><li>全称量词$\forall$（ Universal Quantifier ）： $\forall x$表示个体域里的所有个体x<blockquote><p>对应日常语言中的“一切的”、“所有的”等<br>一元谓词F(x)个体域为D， $\forall xF(x)$真值<br>$\forall xF(x)$为真：$F(a)$为真，对所有$a \in D$<br><strong>$\forall xF(x)$为假：$F(a)$为假，对某个$a \in D$</strong><br>$\forall x\forall yG(x,y)$：个体域里所有个体x,y有关系G<br>$\forall x\forall yG(x,y)$为真：G(a,b)为真，对所有$a,b \in D$<br>$\forall x\forall yG(x,y)$为假：G(a,b)为假，对某对$a,b \in D$</p></blockquote></li><li>存在量词$\exists$（Existential Quantifier ）： $\exists x$表示个体域里有一个个体x<blockquote><p>对应日常语言中的“存在”、“有一个”等<br>一元谓词F(x)个体域为D， $\exists xF(x)$真值<br>$\exists xF(x)$为真：F(a)为真，存在某个$a \in D$<br>$\exists xF(x)$为假：F(a)为假，对任意$a \in D$<br>$\exists x\exists yG(x,y)$：个体域里存在个体x,y有关系G</p></blockquote></li><li>全称量词与存在量词联合<ul><li>$\forall x\exists yG(x,y)$：个体域里任意x,存在个体y, x, y有关系G</li><li>$\exists x\forall yG(x,y)$：个体域里存在x和所有个体y都有关系G</li></ul></li><li>$\forall xF(x), \exists xF(x), F(x)$的联系、区别<ul><li>$F(x)$是不能确定真值的谓词</li><li>$\forall xF(x), \exists xF(x)$都是命题</li><li>x称为约束变元</li></ul></li><li>谓词逻辑符号化几点说明<ul><li>不同的个体域，符号化形式可能不一样，命题真值也可能不同</li><li>一般默认是全总个体域，即包含一切个体</li><li>特性谓词：描述个体变元取值范围的谓词<ul><li><strong>全称量化中，特性谓词常作为蕴涵式的前件</strong><br>$\forall x(M(x) \to F(x))$</li><li><strong>存在量化中，特性谓词常作为合取项之一</strong><br>$\exists x(M(x) \wedge F(x))$</li></ul></li><li>根据命题的实际意义选取全称量词或存在量词</li><li>多个量词同时出现时，不能随意颠倒顺序</li></ul></li></ul><h2 id="一阶逻辑公式及其解释"><a href="#一阶逻辑公式及其解释" class="headerlink" title="一阶逻辑公式及其解释"></a>一阶逻辑公式及其解释</h2><ul><li>一阶谓词语言ℒ（ First-order Predicate Language）的字母表（ Alphabet）<ul><li>非逻辑符号<ul><li>个体常项符号</li><li>函数符号</li><li>谓词符号</li></ul></li><li>逻辑符号<ul><li>个体变项符号</li><li>量词符号</li><li>联结词符号</li><li>括号与逗号</li></ul></li></ul></li><li>一阶谓词语言ℒ的项（Term）：<ul><li>个体常项符号和个体变项符号是项</li><li>若$f(x_1,…,x_n)$是n元函数符号，$t_1,…,t_n$是n个项，则$f(t_1,…,t_n)$是项</li><li>有限次使用以上两项生成的符号串才是项</li></ul></li><li><p>一阶谓词语言ℒ的原子公式（Atomic Formula）：</p><blockquote><p>$F(x_1,…,x_n)$为n元谓词符号<br>$t1,…,tn$为n个项<br>$F(t_1,…,t_n)$为ℒ的原子公式</p></blockquote></li><li><p>一阶谓词语言ℒ的合式公式(谓词公式)(Predicate Formula)：</p><ol><li>原子公式是合式公式</li><li>A为合式公式，则$\neg A$是合式公式</li><li>A，B为合式公式,则$(A\wedge B), (A \lor B), (A \to B), (A \leftrightarrow B)$为合式公式</li><li>如A是合式公式，则$\forall xA, \exists xA$也是合式公式</li><li>只有有限次应用1-4构成的符号串才是合式公式</li></ol></li><li><strong>一张图解释</strong><br><strong>$个体词\xrightarrow{   函数   }项\xrightarrow{   谓词   }原子公式\xrightarrow{  联结词和量词  }合式公式$</strong></li><li>辖域(Scope)：紧接在量词后面括号内的合式公式</li><li>自由变元与指导变元<ul><li>指导变元(Guide Variable)：出现在量词辖域内的变元x</li><li>自由变元(Free Variable) ：非约束出现的变元</li></ul></li><li>闭式(封闭公式)(Closed Formula)：不含自由出现的个体变项的公式</li><li>如何赋予合式公式含义？<blockquote><p>定义域<br>函数变项需要指定具体函数<br>谓词变项需要指定具体谓词</p></blockquote></li><li>解释（Explanation）：非逻辑符号集L生成的一阶语言ℒ，ℒ的解释I由4部分组成<ul><li>非空个体域$D_I$</li><li>I将任意一个个体常项符号$a \in L$映射到$D_I$上的个体$a*$</li><li>I将任意一个n元函数$f \in L$映射到$D_I$上的n元函数$f*: (D_I)^n \to D_I$</li><li>I将任意一个n元谓词$F \in L$映射到$D_I$上的n元关系$R_F$ </li></ul></li><li>$I$下的赋值$\sigma$: 对每一个个体变项符号$x$指定$D_I$中的一个值$\sigma(x)$<br>设公式$A$, 规定：在解释$I$和赋值$\sigma$下<ul><li>取个体域$D_I$</li><li>若$A$中含个体常项符号$a$就把它替换成$\overline a$</li><li>若$A$中含函数符号$f$就把它替换成$\overline f$</li><li>若$A$中含谓词符号$F$就把它替换成$\overline F$</li><li>若$A$中含自由出现的个体变项符号$x$就将它替换成$\sigma(x)$<br>这样得到的公式记为$A’$,称为$A$在$I$下的解释。</li></ul></li><li>合式公式分类：公式A<ul><li>重言式(永真式)（Tautology）：A在任意的解释下为真</li><li>矛盾式(永假式)（Contradiction）：A在任意的解释下为假</li><li>可满足式（Satisfiable）： A在某个解释下为真</li></ul></li><li>设$A_0$是含命题变项$p_1,p_2,\cdots,p_n$的命题公式，$A_1,A_2,\cdots,A_n$是n个谓词公式，用$A_i(1&lt;=i&lt;=n)$处处代替$A_0$中的$p_i$,所得公式$A$称为$A_0$的代换实例(Substitution Instance)<ul><li>如$F(x) \to G(x),\forall xF(x) \to \exists yG(y)$都是$p \to q$的代换实例。</li></ul></li><li>重言式的代换实例都是永真式，矛盾式的代换实例都是永假式</li></ul><h2 id="考试要点-3"><a href="#考试要点-3" class="headerlink" title="考试要点"></a>考试要点</h2><ul><li>主要内容<ul><li>个体词、谓词、量词</li><li>一阶逻辑命题符号化</li><li>一阶语言L<br>   项、原子公式、合式公式</li><li>公式的解释<br>   量词的辖域、指导变元、个体变项的自由出现与约束出现、闭式、解释</li><li>公式的类型<br>   永真式(逻辑有效式)、矛盾式(永假式)、可满足式</li></ul></li><li>基本要求<ul><li>准确地将给定命题符号化</li><li>理解一阶语言的概念</li><li>深刻理解一阶语言的解释</li><li>熟练地给出公式的解释</li><li>深刻理解永真式、矛盾式、可满足式的概念, 会判断简单公式的类型</li></ul></li></ul><h1 id="等值演算与推理"><a href="#等值演算与推理" class="headerlink" title="等值演算与推理"></a>等值演算与推理</h1><ul><li>本章的主要内容<ul><li>一阶逻辑等值式与基本的等值式</li><li>置换规则、换名规则、代替规则</li><li>前束范式</li></ul></li><li>一阶逻辑推理理论<ul><li>本章与其他各章的关系</li><li>本章的先行基础是前四章</li><li>本章是集合论各章的先行基础</li></ul></li></ul><h2 id="等值式与置换规则"><a href="#等值式与置换规则" class="headerlink" title="等值式与置换规则"></a>等值式与置换规则</h2><ul><li>等值式(Equivalence)：公式A,B的等价式$A \leftrightarrow B$为永真式，记作$A \Leftrightarrow B$. 称$A \Leftrightarrow B$是等值式。</li><li>第一类等值式：命题逻辑的重言式的代换实例(重言式的代换实例都是永真式)</li><li><p>第二类等值式：</p><ul><li>消去量词等值式<br>设个体域为有限集$D=\lbrace a_1,a_2,\cdots,a_n \rbrace$,则有<br>(1) $\forall xA(x)\Leftrightarrow A(a_1)\wedge A(a_2)\wedge\cdots\wedge A(a_n)$<br>(2) $\exists xA(x)\Leftrightarrow A(a_1)\lor A(a_2)\lor\cdots\lor A(a_n)$</li><li>量词否定等值式<br>设公式$A(x)$含有自由出现的个体变项$x$,则<br>(1) $\neg\forall xA(x)\Leftrightarrow\exists x\neg A(x)$<br>(2) $\neg\exists xA(x)\Leftrightarrow\forall x\neg A(x)$</li><li>量词辖域收缩与扩张等值式<br>x在公式A(x)中自由出现，但不在B中自由出现<br>$$<br>\begin{split}<br>  \forall x(A(x) \lor B) &amp;\Leftrightarrow \forall xA(x) \lor B<br>  \newline<br>  \forall x(A(x) \wedge B) &amp;\Leftrightarrow \forall xA(x) \wedge B<br>  \newline<br>  \forall x(A(x) \to B) &amp;\Leftrightarrow \exists xA(x) \to B<br>  \newline<br>  \forall x(B \to A(x)) &amp;\Leftrightarrow \forall B \to xA(x)<br>  \newline<br>  \exists x(A(x) \lor B) &amp;\Leftrightarrow \exists xA(x) \lor B<br>  \newline<br>  \exists x(A(x) \wedge B) &amp;\Leftrightarrow \exists xA(x) \wedge B<br>  \newline<br>  \exists x(A(x) \to B) &amp;\Leftrightarrow \forall xA(x) \to B<br>  \newline<br>  \exists x(B \to A(x)) &amp;\Leftrightarrow \exists B \to xA(x)<br>\end{split}<br>$$</li><li>量词分配等值式<br>x在公式A(x)和B(x)中自由出现<br>(1) $\forall x(A(x)\wedge B(x))\Leftrightarrow \forall xA(x) \wedge \forall xB(x)$<br>(2) $\exists x(A(x)\lor B(x))\Leftrightarrow \exists xA(x) \lor \exists xB(x)$<br>(3) $\exists x(A(x)\to B(x))\Leftrightarrow \forall xA(x) \lor \exists xB(x)$<br><strong>注意:全称量词对析取无分配律，存在量词对合取无分配律</strong></li><li>即以下等值式不成立(x在公式A(x)和B(x)中自由出现)<ul><li>$\forall x(A(x)\lor B(x))\Leftrightarrow \forall xA(x) \lor \forall xB(x)$</li><li>提示：任意实数，或者是有理数或者是无理数，或者任意实数是有理数，或者任意实数是无理数</li><li>$\exists x(A(x)\wedge B(x))\Leftrightarrow \exists xA(x) \wedge \exists xB(x)$</li><li>提示：存在实数，既是有理数又是无理数;存在实数是有理数，并且存在实数是无理数</li></ul></li></ul></li><li><p>规则</p><ul><li>置换规则<ul><li>设$\Phi(A)$是含公式$A$的公式, $\Phi(B)$是用公式$B$取代$\Phi(A)$中所有的A之后所得到的公式，那么，若$A \Leftrightarrow B$ 则 $\Phi(A) \Leftrightarrow \Phi(B)$</li><li>一阶逻辑中的置换规则与命题逻辑中的置换规则形式上完全相同，只是在这里$A,B$是一阶逻辑公式。</li></ul></li><li>换名规则<ul><li>设$\Phi(A)$为一公式, 将A中某量词辖域中的一个约束变项的所有出现及相应的指导变元全部改成该量词辖域中未曾出现过的某个个体变项符号，公式中其余部分不变，将所得公式记作$A’$,则$A’ \Leftrightarrow A$.</li></ul></li></ul></li></ul><h2 id="一阶前束范式"><a href="#一阶前束范式" class="headerlink" title="一阶前束范式"></a>一阶前束范式</h2><ul><li>前束范式(Prenex Normal)：一阶逻辑公式满足<ul><li>量词都出现在公式最前面</li><li>量词的辖域一直延伸到公式末</li><li>形如$Q_1x_1Q_2x_2 \cdots Q_kx_k B$</li><li>Q为$\exists$或$\forall$，B不含量词</li></ul></li><li>前束范式存在定理：一阶逻辑任何公式都存在等值的前束范式<ul><li>将公式中的联接词$\to、\leftrightarrow$换为$\wedge,\lor,\neg$</li><li>利用量词否定等值式把深入到原子公式前</li><li>利用换名规则或代替规则</li><li>利用量词辖域的扩张收缩律把量词移到全式的最前面</li><li>注意哪些既约束出现又自由出现的个体变项. 在求前束范式时，要通过换名消去既约束出现又自由出现的个体变项。</li></ul></li></ul><h2 id="一阶逻辑的推理理论"><a href="#一阶逻辑的推理理论" class="headerlink" title="一阶逻辑的推理理论"></a>一阶逻辑的推理理论</h2><ul><li>推理定律<br>除命题逻辑中的11个推理规则外，还有4个消去、引入量词规则:<blockquote><ol><li>全称量词消去规则(简记为$\forall -$)<br>$\forall xA(x) \Rightarrow A(y)$</li><li>全称量词引入规则(简记为$\forall +$)<br>$A(y) \Rightarrow \forall xA(x)$</li><li>存在量词消去规则(简记为$\exists -$)<br>$(\exists xA(x))\wedge (A(y) \to B) \Rightarrow B$或$A(y)\to B \Rightarrow \exists xA(x)\to B$</li><li>存在量词引入规则(简记为$\exists +$)<br>$A(y) \Rightarrow \exists xA(x)$ 或 $B \to A(y) \Rightarrow B \to \exists xA(x)$</li></ol></blockquote></li></ul><p><center> <font size="7"> 集合论 </font> </center></p><ul><li>本部分的主要内容<ul><li>集合代数—-集合的概念和基本运算</li><li>关系—-二元关系的表示、运算、性质、特殊的关系</li><li>函数—-函数定义、性质、运算</li><li>集合的基数—-集合的等势、集合的基数</li></ul></li><li>本部分的基本要求<ul><li>掌握集合及其相关的基本概念</li><li>熟练掌握集合以及关系、函数的基本运算</li><li>了解和使用基本的证明方法</li></ul></li></ul><h1 id="集合代数"><a href="#集合代数" class="headerlink" title="集合代数"></a>集合代数</h1><ul><li>主要内容<ul><li>集合的基本概念—-属于、包含、幂集、空集、文氏图等</li><li>集合的基本运算—-并、交、补、差等</li><li>集合恒等式—-集合运算的算律、恒等式的证明方法 </li></ul></li><li>与后面各章的关系 : 是集合论后面各章的基础</li></ul><h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><ul><li><em>集合</em>是能作为整体论述的事物的集体，又称为类、族、搜集</li><li>组成集合的每个事物叫做这个集合的<em>元素或成员</em>。用符号$\in$表示某个元素属于某个集合，$\notin$表示不属于</li><li>任意元素，对于某一集合而言 ，或属于该集合，或者不属于，二者必居其一，不可兼得。这也符合命题演算中，命题要么是真，要么是假的二值逻辑</li><li>有限集合的元素的个数称为该集合的基数或势,记为$|A|$。<ul><li>外延公理：两个集合A和B相等，即A=B，当且仅当他们有相同的成员（也就是，A的每一元素是B的一个元素而B的每一个元素也是A的一个元素）。</li><li>用逻辑符号表达是： $A=B \Leftrightarrow \forall x(x \in A \leftrightarrow x \in B)$</li></ul></li><li>集合间的包含关系、相等、子集、真子集、空集</li><li>本章中讨论的集合和元素都是限于某一论述域的。我们记该论述域为$E$，又称为全集合。</li><li>含有n个元素的集合简称n元集，它的含有$m$个$(m≤n)$元素的子集称为它的m元子集。</li><li>幂集合<ul><li>定义：由集合$A$的所有子集（包括空集及A本身）所组成的集合叫做A的幂集。</li><li>记以 $P(A)$,即 $P(A) ={B|B \subseteq A}$</li><li>一个给定集合的幂集是唯一的</li><li>设A为一个有限集，A的基数为$|A|$，则$P(A)$的基数$|P(A)|=2|A|$</li></ul></li></ul><h2 id="集合的运算与集合恒等式"><a href="#集合的运算与集合恒等式" class="headerlink" title="集合的运算与集合恒等式"></a>集合的运算与集合恒等式</h2><ul><li>定义<ol><li>A和B的并记为$A∪B$ , 是集合 $A∪B={x|x∈A∨ x∈B}$</li><li>A和B的交记为$A∩B$ , 是集合 $A∩B={x|x∈A∧x∈B}$</li><li>A和B的差，或B关于A的 <strong>相对补</strong>，记为$A－B$,是集合 <strong>$A－B ={x|x∈A∧x \notin B}$</strong></li><li>设A，B是两集合，集合$(A-B)∪(B-A)$称为集合A，B的 <strong>对称差</strong>，记作$A \bigoplus B$。即$A \bigoplus B={x \bigoplus (x \bigoplus A∧x \bigoplus B)∨(x \bigoplus B∧x \bigoplus A)}$<br> <strong>$A \bigoplus B =(A∪B)-(A∩B)$</strong></li><li>设E是论述域而A是E的子集。A的（绝对）补，记为～A，是集合$～A＝E－A＝{x|x∈E∧x \notin A}={x \notin A}$</li><li>设$A$为集合, $A$的元素的元素构成的集合称作$A$的 <strong>广义并</strong>,记作$\cup A$,符号化表示为$\cup A = \lbrace x|\exists z(z\in A \wedge x\in z)\rbrace$</li><li>设$A$为 <strong>非空集合</strong>(否则无意义), $A$的所有元素的公共元素构成的集合称作$A$的广义交,记作$\cap A$,符号化表示为$\cap A = \lbrace x|\forall z(z\in A \to x\in z)\rbrace$</li></ol></li><li>称广义并、广义交、幂集、绝对补运算为一类运算，并、交、相对补、对称差运算为二类运算.<ul><li>一类运算优先于二类运算.</li><li>一类运算之间由右向左顺序进行.</li><li>二类运算之间由括号决定先后顺序.</li></ul></li></ul><h2 id="有穷集的计数"><a href="#有穷集的计数" class="headerlink" title="有穷集的计数"></a>有穷集的计数</h2><ul><li>文氏图(Venn Diagrams)：利用图来图解全集的各子集的关系的图，称为文氏图。<br>  （1）全集合E用一个大矩形表示<br>  （2）设A是E的一个子集，A用圆形表示<br>  （3）通常在图中画有阴影的区域表示新组成的集合</li><li>包含排斥定理(容斥原理):<br>  $|\overline{A_1} \cap \overline{A_2} \cap \cdots \cap \overline{A_n}|=|S|-\sum_{i=1}^{n}|A_i|+\cdots+{(-1)}^n|A_1 \cap A_2 \cap\cdots\cap A_n|$</li><li>欧拉函数(了解)<br>  欧拉函数$\phi$是数论中的一个重要函数，设$n \in N_+ ,\phi(n)$表示$\lbrace 0,1,\cdots,n-1\rbrace$中与$n$互素的数的个数.<br>  $\phi(n) =n\sum_{i=1}^{k}(1-\frac{1}{p_i})$</li></ul><h2 id="集合恒等式"><a href="#集合恒等式" class="headerlink" title="集合恒等式"></a>集合恒等式</h2><table><thead><tr><th>名称</th><th>公式</th></tr></thead><tbody><tr><td>幂等律</td><td>$A \cup A = A$</td></tr><tr><td></td><td>$A \cap A = A$</td></tr><tr><td>结合律</td><td>$(A \cup B)\cup C = A \cup (B \cup C)$</td></tr><tr><td></td><td>$(A \cap B)\cap C = A \cap (B \cap C)$</td></tr><tr><td>交换律</td><td>$A \cup B = B \cup A$</td></tr><tr><td></td><td>$A \cap B = B \cap A$</td></tr><tr><td>分配律</td><td>$A \cup (B \cap C) =  (A \cup B)\cap(A \cup C)$</td></tr><tr><td></td><td>$A \cap (B \cup C) =  (A \cap B)\cup(A \cap C)$</td></tr><tr><td>同一律</td><td>$A \cup \emptyset = A$</td></tr><tr><td></td><td>$A \cap E = A$</td></tr><tr><td>零律</td><td>$A \cup E = E$</td></tr><tr><td></td><td>$A \cap \emptyset = \emptyset$</td></tr><tr><td>排中律</td><td>$A \cup $~$A = E$</td></tr><tr><td>矛盾律</td><td>$A \cap $~$A = \emptyset$</td></tr><tr><td>吸收律</td><td>$A \cup(A \cap B) = A$</td></tr><tr><td></td><td>$A \cap(A \cup B) = A$</td></tr><tr><td>德摩根律</td><td>$A-(B \cup C)=(A-B)\cap(A-C)$</td></tr><tr><td></td><td>$A-(B \cap C)=(A-B)\cup(A-C)$</td></tr><tr><td></td><td>~$(B \cup C) = $ ~$B \cap $~$C$</td></tr><tr><td></td><td>~$(B \cap C) = $ ~$B \cup $~$C$</td></tr><tr><td></td><td>~$\emptyset = E$</td></tr><tr><td></td><td>~$E = \emptyset$</td></tr><tr><td>双重否定律</td><td>~~$A=A$</td></tr></tbody></table><h1 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h1><ul><li>主要内容<ul><li>有序对与笛卡儿积</li><li>二元关系的定义与表示法</li><li>关系的运算</li><li>关系的性质</li><li>关系的闭包</li><li>等价关系与划分</li><li>偏序关系</li></ul></li><li>本章与后面各章的关系<ul><li>是函数的基础</li><li>是图论的基础</li></ul></li></ul><h2 id="有序对与笛卡儿积"><a href="#有序对与笛卡儿积" class="headerlink" title="有序对与笛卡儿积"></a>有序对与笛卡儿积</h2><ul><li>有序对（序偶）：由两个元素$x,y$(允许x=y)按给定顺序排列组成的二元组合<ul><li>符号化：$&lt;x,y&gt;$</li><li>x为第一元素，y为第二元素</li></ul></li><li>笛卡尔积A×B：集合A中元素为第一元素，集合B中元素为第二元素的有序对集$A×B={&lt;x，y&gt;|x \in A \wedge y \in B}$<ul><li>如A，B均是有限集，$|A|=m,|B|=n$,则必有$|A \times B|=mn$</li></ul></li><li>笛卡儿积性质<ul><li>对于任意集合A，$A \times \emptyset = \emptyset，\emptyset \times A=\emptyset$</li><li>一般不满足交换律，当$A\neq\emptyset \wedge B\neq\emptyset \wedge A \neq B时，A \times B \neq B \times A$</li><li>一般不满足结合律，即当A，B，C均非空时，$(A \times B) \times C \neq A \times (B \times C)$</li></ul></li><li>对任意三个集合A，B，C有<br> （1）$A\times(B∪C)=(A \times B) ∪(A \times C)$<br> （2）$A\times(B∩C)=(A \times B)∩(A \times C)$<br> （3）$(B∪C)\times A=(B\times A) ∪(C \times A)$<br> （4）$(B∩C)\times A=(B \times A)∩(C \times A)$<br> （5）$A \subseteq C \wedge B \subseteq D \Leftrightarrow A×B \subseteq C×D$</li></ul><h2 id="二元关系-1"><a href="#二元关系-1" class="headerlink" title="二元关系"></a>二元关系</h2><ul><li>关系是指事物之间（个体之间）的相互联系</li><li>二元关系R：满足下列条件之一的集合<ul><li>集合非空，且它的元素都是有序对</li><li>集合为空集</li></ul></li><li>$A,B$是集合，$A \times B$的子集叫做从A到B的一个二元关系</li><li>特殊的二元关系<ul><li>全域关系$E_A＝A \times A$ </li><li>恒等关系$I_A＝{&lt;x，x&gt;|x∈A}$  </li><li>空关系$\emptyset$</li><li>小于等于关系 $L_A = \lbrace&lt;x,y&gt;|x,y \in A,x&lt;=y$</li><li>整除关系 $D_A = \lbrace&lt;x,y&gt;|x,y \in A,x|y$</li><li>包含关系 $R_\subseteq=\lbrace&lt;x,y&gt;|x,y \in A,x \subseteq y$</li></ul></li><li>给出一个关系的方法有3种：集合表达式、关系矩阵和关系图。</li><li>设$A=\lbrace x_1,x_2,\cdots,x_n \rbrace$, $R$是$A$上的关系，令<br>  $$<br>  r_{ij}=<br>  \begin{cases}<br>  1 &amp; 若x_i R x_j \newline<br>  0 &amp; 若x_i  \not R  x_j<br>  \end{cases}<br>  $$</li><li>关系图，直接由关系矩阵作图即可。</li></ul><h2 id="关系的运算"><a href="#关系的运算" class="headerlink" title="关系的运算"></a>关系的运算</h2><ul><li>设R是二元关系<ul><li>R中所有有序对的第一元素构成的集合称作$R$的$定义域$,记作$domR$,形式化表示为$domR=\lbrace x|\exists y (&lt;x,y&gt; \in R)\rbrace$</li><li>R中所有有序对的第二元素构成的集合称作$R$的$定义域$,记作$ranR$,形式化表示为$ranR=\lbrace y|\exists x (&lt;x,y&gt; \in R)\rbrace$</li><li>R的定义域和值域的并集称作R的域，记作$fldR$,形式化表示为$fldR=domR \cup ranR$</li></ul></li><li>设R为二元关系，R的逆关系，简称为R的逆，记作$R^{-1}$,其中$R^{-1}=\lbrace&lt;x,y&gt;|&lt;y,x&gt; \in R\rbrace$</li><li>设$F,G$为二元关系，G对F的 <strong>右复合</strong>记作$F \circ G$,其中$F \circ G=\lbrace&lt;x,y&gt;|\exists t(&lt;x,t&gt; \in F\wedge&lt;t,y&gt;\in G$</li><li>设$R$为二元关系，A是集合,<ul><li>R在A上的 <strong>限制</strong> 记作$R \upharpoonright A=\lbrace&lt;x,y&gt;|xRy \wedge x \in A\rbrace$</li><li>A在R下的 <strong>像</strong> 记作$R[A]$,其中$R[A]=ran(R \upharpoonright A)$</li></ul></li><li>优先顺序：<ul><li>逆运算优先于其他运算</li><li>关系运算优先于集合运算</li><li>没有规定优先权的运算以括号决定运算顺序</li></ul></li><li>设F是任意的关系，则<ul><li>$(F^{-1})^{-1} = F$</li><li>$domF^{-1}=ranF,ranF^{-1}=domF$</li></ul></li><li>设$F,G,H$是任意的关系，则<ul><li>$(F \circ G) \circ H = F \circ (G \circ H)$</li><li>$(F \circ G)^{-1}=G^{-1} \circ F^{-1}$</li></ul></li><li>设$R$为$A$上的关系,则$R \circ I_A = I_A \circ R = R$<ul><li>$R \circ (S∪T)=R \circ S∪R \circ T$</li><li>$R \circ (S∩T) \subseteq R \circ S∩R \circ T$</li><li>$(S∪T) \circ X=S \circ X∪T \circ X$</li><li>$(S∩T) \circ X \subseteq S \circ X∩T \circ X$</li></ul></li><li>设$R$为关系,$A,B$为集合，则<ul><li>$R↾(A∪B) = R↾A∪R↾B$</li><li>$R[A∪B] = R[A]∪R[B]$</li><li>$R↾(A∩B) = R↾A∩R↾B$</li><li>$R[A∩B] \subseteq R[A]∩R[B]$</li></ul></li><li>设$R$为$A$上的关系，n为自然数，则R的n次幂定义为<ul><li>$R^0=\lbrace&lt;x,x&gt;|x \in A\rbrace=I_A$</li><li>$R^{n+1}=R^n \circ R$</li><li>定理: 设R是集合A上的关系，$m,n∈N$<ul><li>$R^m \circ R^n=R^{m+n}$</li><li>$(R^m)^n=R^{mn}$</li><li>证明思路：使用归纳法并利用复合关系的结合律</li></ul></li><li>定理：设A为n元集，R是A上的关系，则存在自然数$s$和$t$，使得$R^s=R^t$</li></ul></li></ul><h2 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h2><ul><li>若$\forall x(x \in A \to &lt;x,x&gt; \in R)$，则称$R$在$A$上是 <strong>自反</strong>的。</li><li><p>若$\forall x(x \in A \to &lt;x,x&gt; \notin R)$,则称$R$在$A$上是 <strong>反自反</strong>的。</p><blockquote><ul><li>关系矩阵的特点？<br>自反关系的关系矩阵的对角元素均为1<br>反自反关系的关系矩阵的对角元素均为0</li><li>关系图的特点？<br>自反关系的关系图中每个顶点都有环<br>反自反关系的关系图中每个顶点都没有环</li><li>定理：R是A上的关系，则：<br>R是自反关系的充要条件是$I_A \subseteq R$<br>R是反自反关系的充要条件是$R∩IA=Ф$</li></ul></blockquote></li><li><p>若$\forall x\forall y(x,y \in A \wedge &lt;x,y&gt; \in R \to &lt;y,x&gt; \to R$,则称$R$为$A$上 <strong>对称</strong>的关系。</p><blockquote><ul><li>关系矩阵特点？<br>对称关系的关系矩阵是对称矩阵</li><li>关系图特点？<br>如果两个顶点之间有边，一定是一对方向相反的边（无单边）</li><li>定理： R在A上对称当且仅当$R=R^{-1}$</li></ul></blockquote></li><li>若$\forall x\forall y(x,y \in A \wedge &lt;x,y&gt; \in R \wedge &lt;y,x&gt; \in R \to x=y$,则称$R$为$A$上 <strong>反对称</strong>的关系。<blockquote><ul><li>反对称关系矩阵和关系图特点？<br>若$r_{ij}=1$，且$i≠j$， 则$r_{ji}=0$</li><li>如果两个顶点之间有边，一定是一条有向边（无双向边）</li><li>定理： R在A上反对称当且仅当$R∩R{-1} \subseteq IA$</li></ul></blockquote></li><li>设$R$为A上的关系，若$\forall x\forall y\forall z(x,y,z\in A \wedge &lt;x,y&gt;\in R\wedge &lt;y,z&gt; \in R \to &lt;x,z&gt; \in R$,则称$R$为$A$上 <strong>传递</strong>的关系。<blockquote><ul><li>传递关系关系图特点？<br>如果结点a能通过有向弧组成的有向路径通向结点x,则a必须有有向弧直接指向x,否则R就不是传递的</li><li>定理：R在A上传递当且仅当$R \circ R \subseteq R$</li></ul></blockquote></li></ul><h2 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h2><ul><li><p>定义：R是非空集合A上的关系,若A上另外有一个关系R’满足如下三条：</p><blockquote><ul><li>$R’$是自反的(对称的，传递的）</li><li>$R \subseteq R’$</li><li>A上任何一个满足以上两条的关系$R”$，均有$R’ \subseteq R”$<br>称关系R’为R的自反(对称,传递)闭包,记作$r(R) (s(R),t(R))$<ul><li>R’是在R的基础上添加有序对</li><li>添加元素的目的是使R’具有自反性(对称性,传递性)</li><li>添加后使之具有自反性(对称性,传递性)的所有关系中R’是最小的一个</li></ul></li></ul></blockquote></li><li><p>定理</p><ul><li>$r(R)=R \cup R^0$</li><li>$s(R)=R \cup R^{-1}$</li><li>$t(R)=R \cup R^2 \cup \cdots$</li></ul></li><li>给定关系$R，r(R)，s(R)，t(R)$的关系矩阵分别为$M , M_r , M_s , M_t$,那么：<ul><li>$Mr=M+E$</li><li>$Ms=M+M$</li><li>$Mt=M+M2+M3+…$</li></ul></li><li>关系图分别为$G，G_r，G_s，G_t$，那么：<ul><li>考察G的每个顶点，如果没有环就加上一个环，最终得到的是Gr</li><li>考察G的每一条边，如果有一条从$x_i到x_j$的单向边，则在G中加一条$x_j到x_i$的反方向边，最终得到$G_s$</li><li>考察G的每个顶点$xi$,找出从$x_i$出发的所有2步，3步，…，n步长的路径。设路径的终点为$x_{j1},x_{j2},…,x_{jk}$。如果没有从$x_i$到$x_{jl}$的边，就加上这条边，最终得到$G_t$</li></ul></li><li>定理：设A是一集合，R是A上的二元关系，则有：<ul><li>R是自反的当且仅当$r(R)＝R$</li><li>R是对称的当且仅当$s(R)＝R$</li><li>R是可传递的当且仅当$t(R)＝R$</li></ul></li><li>定理：设A是集合，R1和R2是A上的二元关系，$R1 \subseteq R2$，则有：<ul><li>$r(R1) \subseteq r(R2)$</li><li>$s(R1) \subseteq s(R2)$</li><li>$t(R1) \subseteq t(R2)$</li></ul></li><li>定理：设X是一集合，R是X上的二元关系，则有：<ul><li>若R是自反的，则$s(R),t(R)$也自反</li><li>若R是对称的，则$r(R),t(R)$也对称</li><li>若R是可传递的，则$r(R)$也可传递</li><li>若R是对称的，则$t(R)$也对称</li></ul></li></ul><h2 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h2><ul><li>若非空集合A上的关系R, 满足自反、对称、可传递，则称R为A上的 <strong>等价关系</strong>。即若$&lt;x,y&gt; \in R$,称$x$等价于$y$,记作$x$~$y$.</li><li>设$R$为非空集合$A$上的等价关系，$\forall x \in A$,令$[x]_R = \lbrace y|y \in A \wedge xRy\rbrace$ ,称为x关于R的等价类,简称为x的等价类。简记为$[x]$或$\overline{x}$<ul><li>等价类$[x]_R$是一个集合，$[x]_R \subseteq A ([x]R$是A的子集)</li><li>$[x]_R$中的元素是在A中，所有与x具有等价关系R的元素所组成的集合</li><li>在等价关系中的关系图中，一个最大连通子图中的点就是一个等价类</li></ul></li><li>定理<ul><li>设A是一个集合，R是A上的等价关系，$xRy$当且仅当$[x]=[y]$</li><li>设A是一个集合，R是A上的等价关系，对于所有$x,y∈A$，或者$[x]=[y]$，或者$[x]∩[y]=Ø$</li><li>设R是集合A上的等价关系，则$A=∪{[x]|x \in A}$</li></ul></li><li>设$R$为非空集合$A$上的等价关系,以$R$的所有等价类作为元素的集合称为$A$关于$R$的 <strong>商集</strong>，记作$A/R$，即：$A/R=\lbrace[x]_R|x \in A\rbrace$</li><li>设$A$为非空集合,若$A$的子集族$\pi(\pi\subseteq P(A)$,是A的子集构成的集合）满足下列条件:<ul><li>$\emptyset\notin\pi$</li><li>$\forall x\forall y(x,y\in\pi\wedge x\neq y \to x\cap y = \emptyset$</li><li>$\cup\pi = A$<br>则称$\pi$是$A$的一个 <strong>划分</strong>,称$\pi$中的元素为$A$的划分块。</li></ul></li></ul><blockquote><p>等价关系与划分有一一对应关系<br> 划分到等价关系转化：A是一非空集合，S是A的一个划分，下述关系必定是一个等价关系<br>$R={&lt;x,y&gt; | x, y\in A \wedge x,y在S的同一划分}$<br> 等价关系到划分的转化：设A是非空集合，R是A上的等价关系。R的商集是A的划分</p></blockquote><h2 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h2><ul><li>次序在现实生活中常见：<br>  小于，包含等</li><li>研究序理论的动机：<ul><li>研究一般次序关系</li><li>推导出一般序关系的性质</li><li>这些关系可以应用于所有特定的序关系</li></ul></li><li>设$R$为非空集合A上的关系。如果$R$是自反、<strong> <em>反</em> 对称</strong>和传递的,则称R为A上的 <strong>偏序关系</strong>。记作$≼$，设$≼$ 为偏序关系,如果$&lt;x,y&gt;\in≼$,则记作$x≼y$，读作”x小于等于y”</li><li>设$≼$为非空集合$A$上的偏序关系，定义<ul><li>$\forall x,y\in A,x&lt;y\Leftrightarrow x≼y\wedge x\neq y$</li><li>$\forall x,y\in A,x与y可比\Leftrightarrow x≼y\lor y≼x$</li></ul></li><li>设$R$为非空集合$A$上的偏序关系，如果$\forall x,y\in A,x,y$均可比，则称$R$为A上的全序关系（线序关系）</li><li>集合$A$和$A$上的偏序关系$≼$一起称作 <strong>偏序集</strong>，记作$&lt;A,≼&gt;$</li><li>设$&lt;A,≼&gt;$为偏序集，$\forall x,y\in A$,如果$x&lt;y$且不存在$z\in A$使得$x&lt;z&lt;y$，则称$y$覆盖$x$.</li><li>哈斯图思路<ul><li>哈斯图思路：</li><li>所有结点的自回路均省略</li><li>省略所有弧上的箭头,适当排列A中元素的位置,如$a≼b$,则a画在b的下方</li><li>如$a≼b,b≼c$,则必有$a≼c$, a到b有边, b到c有边,则a到c的无向弧省略</li><li>条件2，3等于说如果b覆盖a,则画一条从a到b的弧线，否则不画</li></ul></li><li>最小(大)元：设$&lt;A, ≼&gt;$是偏序集,集合$B \subseteq A$<ul><li>最大元$b∈B$：$\forall a∈B$,均有$a≼b$</li><li>最小元$b∈B$：$\forall a∈B$,均有$b≼a$</li><li>如果A的子集B存在最大(小)元素,则最大(小)元素是唯一的</li><li>最大(小)元可能不存在</li></ul></li><li>极大(小)元：设$&lt;A, ≼&gt;$是偏序集,$B \subseteq A$<ul><li>极大元$b∈B$：$\forall a∈B,如b≼a,则a＝b$</li><li>不存在$a∈B$，$b≺a$</li><li>极小元$b∈B$：$\forall a∈B,如a≼b,则a＝b$</li><li>不存在$a∈B$，$a≺b$</li><li>说明<ul><li>极大元未必是最大元</li><li>极大元未必是唯一的</li><li>如果B是有限集,则B必存在极大元</li><li>最大元就是极大元</li></ul></li></ul></li><li>上(下)界：设$&lt;A, ≼&gt;$是偏序集, $B \subseteq A, a∈A$<ul><li>B的上界a：对每个$b∈B,有b≼a$</li><li>B的下界a：对每个$b∈B,有a≼b$</li><li>上下界不一定唯一</li></ul></li><li>上(下)确界：设$&lt;A, ≼&gt;$是偏序集, $B \subseteq A$<ul><li>最小上界：$C=\lbrace b|b为B的上界\rbrace$的最小元</li><li>最大下界：$D=\lbrace b|b为B的下界\rbrace$的最大元</li><li>说明<ul><li>B的最小元一定是B的下界，同时也是B的最大下界；B的最大元一定是B的上界，同时也是B的最小上界</li><li>最小上界或最大下界可能不存在</li><li>若存在最小上界或最大下界，是唯一的</li></ul></li></ul></li><li>拓扑排序：给定一个非空有限的偏序集合$&lt;A,≼’&gt;$，构造出一个全序集合$&lt;A, ≼&gt;$ ，使得每当$a≼’b$有$a≼b$，方法如下：<ul><li>选取A的极小元a，使a是&lt;A, ≼&gt;列表表示中的第一个元素</li><li>对子集$A-{a}$重复这一过程，每次一个新的极小元素被找到，它在$&lt;A,≼&gt;$的列表表示中成为下一个元素</li><li>重复这一过程，直到A的元素被抽完</li></ul></li></ul><h2 id="考试要点-4"><a href="#考试要点-4" class="headerlink" title="考试要点"></a>考试要点</h2><ul><li>有序对：<br>由两个元素x，y按给定顺序排列组成的二元组合</li><li>笛卡儿积：<br>集合A中元素为第一元素，集合B中元素为第二元素的有序对集</li><li>二元关系R：<br>满足下列条件之一的集合：<br>集合非空，且它的元素都是有序对<br>集合为空集</li><li>从A到B的关系：<br>A，B是集合，A×B的任何子集所定义的二元关系</li><li>A上的关系：<br>A=B<br>空关系，全域关系，恒等关系，包含关系</li><li>关系的表示法：<br>集合表达式、关系矩阵、关系图</li><li>关系的八种运算</li><li>关系运算的五种性质</li><li>关系的三种闭包</li><li>A上的等价关系</li><li>商集</li><li>等价类</li><li>划分</li><li>A上的偏序关系和偏序集<br>基本要求<blockquote><p>熟练掌握关系的三种表示法<br>能够判定关系的性质，以及等价关系、偏序关系<br>掌握含有关系运算的集合等式<br>掌握等价关系、等价类、商集、划分、哈斯图、偏序集等概念<br>计算$A \times B, dom R, ranR, fldR, R^{-1}, R \circ S , R^n , r(R), s(R), t(R)$<br>求等价类和商集A/R<br>给定A的划分$\pi$，求出$\pi$所对应的等价关系<br>求偏序集中的极大元、极小元、最大元、最小元、上界、下界、上确界、下确界<br>掌握基本的证明方法<br>证明涉及关系运算的集合等式<br>证明关系的性质、证明关系是等价关系或偏序关系</p></blockquote></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义与性质"><a href="#函数的定义与性质" class="headerlink" title="函数的定义与性质"></a>函数的定义与性质</h2><ul><li>$B^A$求法  $B^A=\lbrace f|f:A\to B\rbrace$<ul><li>$A=\lbrace 1, 2, 3\rbrace, B=\lbrace a,b \rbrace$，求$B^A$(PPT_Chapter 8 Page8)</li></ul></li><li>函数的像、完全原像概念（课本P146）</li><li><strong>单满双射概念</strong>(课本P147) -&gt; 判断函数类型<ul><li>例8.4 (1)(2)(5)</li><li>例8.5 (1)(2)(6)(7)</li><li>构造双射函数 例8.6 (1)</li></ul></li><li>常用函数(课本P150)<ul><li>常函数</li><li>恒等函数</li><li>单调函数</li><li>特征函数(PPT_Chapter 8 Page18)</li><li>自然映射(PPT_Chapter 8 Page20)</li></ul></li></ul><h2 id="函数的复合与反函数"><a href="#函数的复合与反函数" class="headerlink" title="函数的复合与反函数"></a>函数的复合与反函数</h2><ul><li>会求函数的复合函数$F \circ G$(PPT_Chapter 8 Page25)</li><li>复合函数的单满双射性质（课本P153）</li><li>逆函数（反函数）必须是双射函数</li></ul><h2 id="双射函数与集合的基数"><a href="#双射函数与集合的基数" class="headerlink" title="双射函数与集合的基数"></a>双射函数与集合的基数</h2><ul><li>等势(存在从A到B的双射函数)<ul><li>会判断两个集合是否等势（课本P156-159）、</li><li>具有自反、对称、传递性。</li></ul></li><li>康托定理：(1) $N\not\approx R$ (2) 对任意集合A都有$A\not\approx P(A)$</li><li>优势（存在A到B的单势函数，则称B优势于A,记作$A≼·B$）、真优势<ul><li>性质：自反性、传递性</li><li>$A≼·B \wedge B≼·A \to A\approx B$</li></ul></li><li>自然数集合(课本P162)<ul><li>空集和后继$n^+$定义而来</li><li>三歧性</li><li>有穷集当且仅当它与某个自然数集等势，否则称为无穷集。</li></ul></li><li>基数<ul><li>对于有穷集合A，称与A等势的那个唯一自然数为A的基数,记作$cardA$或(|A|)<ul><li>即$card A = n \Leftrightarrow n$ </li><li>基数即为集合中不同元素的个数</li></ul></li><li>自然数集合$N$的基数记作$ℵ_0$(阿列夫零)</li><li>实数集$R$的基数记作$ℵ$（阿列夫)</li><li>会求集合基数（课本P163)</li></ul></li><li>可数集($cardA≤ℵ_0$)<ul><li>如$\lbrace a,b,c,\rbrace ,  N  , Z , Q$</li><li>不可数集如$R , (0,1) $</li></ul></li></ul><p><center> <font size="7"> 代数结构 </font> </center></p><h1 id="代数系统"><a href="#代数系统" class="headerlink" title="代数系统"></a>代数系统</h1><h2 id="二元运算及其性质"><a href="#二元运算及其性质" class="headerlink" title="二元运算及其性质"></a>二元运算及其性质</h2><ul><li>二元运算<ul><li>封闭与不封闭</li><li>存在性与唯一性</li></ul></li><li>一元运算<ul><li>在R上求平方根（不满足唯一性和存在性)</li></ul></li><li><strong>交换律、结合律</strong></li><li><strong>幂等律</strong><ul><li>$forall x \in S , x \circ x = x$</li><li>$x$称为幂等元</li></ul></li><li><strong>分配律与吸收律</strong>(课本P180)</li><li>(左、右)单位元（也称为幺元）</li><li>(左、右)零元（PPT_Chapter 9 Page20)</li><li>(左、右)逆元(逆元存在性是对集合中的元素而言的)<ul><li>证明定理设Z是集合, *是Z上的二元运算,并且是可结合的，运算*的幺元是1。若$x∈Z$有左逆元和右逆元,则它的左逆元等于右逆元,且逆元是唯一的。(PPT_Chapter 9 Page24)</li><li>综合练习题(PPT_Chapter 9 Page50、52)</li></ul></li><li><strong>消去律</strong>(课本P183)</li></ul><h2 id="代数系统-1"><a href="#代数系统-1" class="headerlink" title="代数系统"></a>代数系统</h2><ul><li>代数系统组成（非空集合、运算、特异元素（代数常数））</li><li>同类型代数系统:具有相同个数的运算、代数常数，且对应运算的元数相同</li><li>运算封闭(PPT_Chapter 9 Page37)</li><li>子代数系统<ul><li>会判断子代数系统   如：$&lt;N,-&gt;$不是$&lt;Z,-&gt;$的子代数系统</li><li>平凡子代数（最大、最小子代数）</li><li>真子代数</li></ul></li><li>积代数、因子代数<ul><li>积代数的运算性质与因子代数相同</li><li>$e_1,e_2$是子代数的代数常数,则$&lt;e_1,e_2&gt;$是积代数的代数常数</li><li>如果$x,y$是子代数的可逆元素,则$&lt;x,y&gt;$是积代数的可逆元素,逆元是$&lt;x^{-1},y^{-1}&gt;$</li><li>积代数保留了因子代数的分配律和吸收律，但不保留消去律。（课本P188）</li></ul></li></ul><h2 id="代数系统的同态与同构"><a href="#代数系统的同态与同构" class="headerlink" title="代数系统的同态与同构"></a>代数系统的同态与同构</h2><ul><li>同态(映射)概念(课本P189)<ul><li>单同态、满同态、双同态（同构)</li><li>自同态</li><li>零同态 </li></ul></li><li>说明：判别或证明同态映射的方法<br>  (1) 先判断（或证明）f 是$G_1$到$G_2$的映射$f:G_1 \to G_2$.  如果已知$f:G_1 \to G_2$，则这步判断可以省去.<br>  (2) $\forall x, y\in G1$, 验证 $f(x \times y) = f(x) \times f(y)$<br>  (3) 判断同态性质只需判断函数的单射、满射、双射性即可.</li></ul><h1 id="群与环"><a href="#群与环" class="headerlink" title="群与环"></a>群与环</h1><h2 id="群的定义及性质"><a href="#群的定义及性质" class="headerlink" title="群的定义及性质"></a>群的定义及性质</h2><ul><li>群分类<ul><li>半群：代数系统上成立结合律。</li><li>幺半群（独异点）: 有幺元的半群</li><li>群（幺半群且每个元素均有逆元)</li><li>Klein四元群</li><li><strong>会验证群类型(定义验证，注意运算封闭性)</strong></li></ul></li><li>概念<ul><li>有限群、无限群</li><li>群的阶</li><li>平凡群</li><li>交换群(阿贝尔群)</li><li>群中元素的幂(PPT_Chapter 10 Page12)</li><li>群中元素的阶（也叫周期）,记作$|a|=k$(k为使$a^k=e$成立的最小正整数)</li></ul></li><li>幂运算性质</li><li>证明消去律和定理10.3、例10.7(课本P197-198)</li></ul><h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><ul><li>子群就是群的子代数<ul><li>真子群</li><li>子群说明：&lt;H,*&gt;是子群, 则<ul><li>H对于运算*是封闭的</li><li>G的幺元e在H内</li><li>H的每个元素的逆元仍在H内(对逆运算封闭)。至于运算的结合律,由于在G中成立,对于H必然成立</li><li>如H构成子群,必然是非空的,至少有幺元e</li></ul></li><li><strong>证明和使用子群判定定理</strong>(课本P199)</li><li>会求由$a$的幂次生成的子群,记作$&lt;a>=\lbrace a^k|k\in Z\rbrace$</li><li>中心（群中所有可交换元素构成的集合）</li></ul></li><li>子群格<ul><li>会画哈斯图</li></ul></li></ul><h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><ul><li>证明群中元素相等的基本方法就是用结合律、消去律、单位元及逆元的惟一性、群的幂运算规则等对等式进行变形和化简.</li><li>证明子集相等的基本方法就是证明两个子集相互包含</li><li>证明与元素的阶相关的命题，如证明阶相等，阶整除等. 证明两个元素的阶r 和 s 相等或证明某个元素的阶等于r，基本方法是证明相互整除.在证明中可以使用结合律、消去律、幂运算规则以及关于元素的阶的性质. 特别地，可能用到a为1阶或2阶元的充分必要条件是$a^{-1} = a$ </li></ul><h1 id="格与布尔代数"><a href="#格与布尔代数" class="headerlink" title="格与布尔代数"></a>格与布尔代数</h1><h2 id="格的定义与性质"><a href="#格的定义与性质" class="headerlink" title="格的定义与性质"></a>格的定义与性质</h2><ul><li>格：偏序集中任意元素均有最小上界和最大下界<ul><li>$x\lor y$表示最小上界</li><li>$x\wedge y$表示最大下界</li><li>幂集格</li></ul></li><li>对偶命题</li><li>格的运算$\lor \wedge$满足交换、幂等、结合、吸收律($a\lor(a\wedge b)=a, a\wedge(a\lor b)=a$)<ul><li>注意这里的$\lor \wedge$是最小上界和最大下界</li></ul></li><li>格的代数系统定义<ul><li><strong>证明定理11.2</strong>(课本P225)</li><li>对应定理(PPT_Chapter 11 Page15)</li></ul></li><li>子格</li></ul><h2 id="分配格、有补格与布尔代数"><a href="#分配格、有补格与布尔代数" class="headerlink" title="分配格、有补格与布尔代数"></a>分配格、有补格与布尔代数</h2><ul><li>分配格<ul><li>会判断分配格<ul><li>$L$是分配格当且仅当$L$中不含与钻石格、五角格同构的子格.</li><li>小于5元的格都是分配格</li><li>任何一条链都是分配格</li></ul></li></ul></li><li>有补格<ul><li>全上界、全下界、有界格</li><li>补元(PPT_Chapter 11 Page28)</li><li>有界分配格补元若存在则唯一。</li><li>有界格中所有元素补元均存在则称为 <strong>有补格</strong></li></ul></li><li>布尔代数（布尔格)<ul><li><img src="/2018/06/05/discretemathfinalreview/pic1.png" title="格"></li><li>也叫有补分配格，记作$&lt;B,\wedge,\lor,’,0,1>$其中$’$为求补运算</li><li>集合代数、命题代数(PPT_Chapter 11 Page39)</li><li><strong>定理11.7 必看</strong>（双重否定律与德摩根律）</li><li>等价定义（交换律、分配律、同一律、补元律）</li></ul></li><li>原子</li></ul><p><center> <font size="7"> 图论 </font> </center><br>知识点过于零散，且多为信息学竞赛/ACM竞赛中重复知识，只针对部分概念：<br>考试重点：欧拉图、哈密顿图、最小生成树、树的遍历</p><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>顶点数称作图的 <strong>阶</strong>，n个顶点的图称作n阶图。</li><li>零图：无边图；n阶零图记作$N_n$. 一阶零图$N_1$称为平凡图。</li><li>空图：顶点集为空集,符号化为:$\emptyset$</li><li>标定图与非标定图:给顶点和边加上符号</li><li>有向图的无向化的无向图称为基图。</li><li>边与端点的关联次数:0,1,2</li><li>点相邻:有边相连； 边相邻:共点</li><li>孤立点:无边关联的点</li><li>(闭)邻域、关联集、先驱、后继</li><li><strong>平行边</strong>：即重边，平行边的边数称为 <strong>重数</strong></li><li>简单图:不含平行边、环(离散数学中的环即是自环)的图称为 <strong>简单图</strong></li><li>度数（入度、出度）、最大度、最小度</li><li>悬挂顶点：度数为1的顶点。与之关联的边称作 <strong>悬挂边</strong>。</li><li><strong>握手定理</strong><ul><li>无向图中，所有顶点的度数之和等于边数的两倍</li></ul></li></ul><h1 id="资料合集"><a href="#资料合集" class="headerlink" title="资料合集"></a>资料合集</h1><p>来自由薛辉老师离散QQ群 :<br><a href="/2018/06/05/discretemathfinalreview/xh.zip" title="点击下载 薛辉老师 所有课件">点击下载 薛辉老师 所有课件</a></p><p>来自外班同学:<br><a href="/2018/06/05/discretemathfinalreview/yp.zip" title="点击下载 杨鹏老师 所有课件">点击下载 杨鹏老师 所有课件</a></p><p>来自外班同学:<br><a href="/2018/06/05/discretemathfinalreview/half.zip" title="点击下载 计科考试真题">点击下载 计科考试真题</a></p><p>来自倒数第二节复习课:<br><a href="/2018/06/05/discretemathfinalreview/example.zip" title="点击下载 最后例题">点击下载 最后例题</a></p><!---<meta http-equiv="refresh" content="20">--->]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;考试结构&lt;blockquote&gt;
&lt;p&gt;10道选择题(含多选,但答案不超过两个)20分&lt;br&gt;3道证明题来自于集合论和代数结构（重难点)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt; &lt;font size=&quot;7&quot;&gt; 数理逻辑 &lt;/
      
    
    </summary>
    
      <category term="期末复习" scheme="http://www.zjdx1998.ml/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="期末复习" scheme="http://www.zjdx1998.ml/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="离散数学" scheme="http://www.zjdx1998.ml/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>大一下学期面向对象程序设计（1）期末复习</title>
    <link href="http://www.zjdx1998.ml/2018/06/05/c-review/"/>
    <id>http://www.zjdx1998.ml/2018/06/05/c-review/</id>
    <published>2018-06-05T02:56:39.000Z</published>
    <updated>2018-06-11T09:56:08.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="期末复习总览"><a href="#期末复习总览" class="headerlink" title="期末复习总览"></a>期末复习总览</h1><h2 id="占比分布"><a href="#占比分布" class="headerlink" title="占比分布"></a>占比分布</h2><pre><code>期末 70%作业 20%考勤 10%</code></pre><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><pre><code>阅读程序 4题各5分填空 2题各10分 5空上机 3*20分</code></pre><h2 id="考试要点"><a href="#考试要点" class="headerlink" title="考试要点"></a>考试要点</h2><h3 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h3><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><pre><code>什么时候使用？ 传值，返回值例子(共调用3+2次) :    add(cls x,cls y){        return x+y;     }    add(x,y) </code></pre><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><h3 id="Composition函数初始化"><a href="#Composition函数初始化" class="headerlink" title="Composition函数初始化"></a>Composition函数初始化</h3><pre><code>先对成员对象初始化,构造函数初始化列表</code></pre><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><pre><code>必须重载为全局函数</code></pre><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><pre><code>纯虚函数后加 = 0</code></pre><h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><pre><code>对象释放</code></pre><h1 id="分章复习"><a href="#分章复习" class="headerlink" title="分章复习"></a>分章复习</h1><h2 id="Chapter-9-类（1）"><a href="#Chapter-9-类（1）" class="headerlink" title="Chapter 9 类（1）"></a>Chapter 9 类（1）</h2><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><pre><code>`#ifndef FILENAME_H``#define FILENAME_H``#endif`</code></pre><h3 id="Sizeof"><a href="#Sizeof" class="headerlink" title="Sizeof"></a>Sizeof</h3><pre><code>只包括数据成员的大小VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。比较以下例子    class test1{        char c;    } sizeof : 1    class test2{        char a,b,c,d,e;    } sizeof : 5    class test3{        int num; char a;    } sizeof : 8    class test4{        int num; char a,b,c,d,e;    } sizeof : 12    class test5{        char a;int num;char b;    } sizeof : 12</code></pre><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><pre><code>每一个成员函数都有一个隐藏的指针类型形参：this&lt;类名&gt; *const  this通过对象调用成员函数时，编译程序会把对象地址作为隐含参数传递给形参this访问this指向对象的成员时：this-&gt;  (也可以省略不写)</code></pre><h3 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h3><pre><code>A.h A.cpp 编译-&gt; A.objB.cpp 编译 B.obj   A.obj B.obj 链接 -&gt; B.exe软件供应商在他们的产品中只需提供头文件和类库(目标模块)，而不需提供源代码。</code></pre><h3 id="访问函数与工具函数"><a href="#访问函数与工具函数" class="headerlink" title="访问函数与工具函数"></a>访问函数与工具函数</h3><ol><li>访问(access)函数,public,用来读取或显示数据,如<code>setName,getName。如vector.empty()</code></li><li>工具(utility)函数,private,一般在public函数里面被使用。</li></ol><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li><p>缺省构造函数：</p><ul><li>不带参数的构造函数</li><li><p><strong>所有参数都有默认值的构造函数</strong><br>考虑以下例子为什么编译失败(缺省构造函数重载失败)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;  </span><br><span class="line">    int x, y;</span><br><span class="line">public:</span><br><span class="line">    A(int x1 = 0,int y1 = 0)          </span><br><span class="line">        x = x1;</span><br><span class="line">        y = y1;</span><br><span class="line">    &#125; </span><br><span class="line">    A(int x1)&#123;</span><br><span class="line">        x = x1;</span><br><span class="line">        y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>只要类中提供了构造函数，即使没有提供缺省构造函数，编译程序将不再提供缺省构造函数。</p></li></ul></li><li>析构函数<ul><li>析构函数是一个特殊的成员函数，它的名字同类名，并在前面加“～”字符，用来与构造函数加以区别。析构函数不接收任何参数，也不可以指定返回类型。</li><li>一个类中只能定义一个析构函数，析构函数不能重载，且必须是公有的。</li><li>下面两种情况，析构函数将会被自动调用<ul><li>如果一个对象被定义在一个函数体内，则当这个函数结束时，该对象的析构函数被自动调用；</li><li>当一个对象是使用new运算符被动态创建的，在使用delete运算符释放它时，delete将会自动调用析构函数</li></ul></li></ul></li></ul><h3 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h3><p><a href="https://blog.csdn.net/fx677588/article/details/52687707" target="_blank" rel="noopener">具体可以参考这里</a></p><ul><li>全局对象：在任何函数(含main)执行前，构造；在程序结束时，析构.</li><li>局部对象：(栈区)<ul><li>自动变量：对象定义时，构造；块结束时，析构.</li><li>静态变量：首次定义时，构造？；程序结束时，析构.</li></ul></li><li>对象间调用构造函数和析构函数的顺序恰好相反. 全局和静态对象(均为静态存储类别)同理.<ul><li>特例1：调用exit函数退出程序执行时，不调用剩余<em>自动对象</em>的析构函数.   </li><li>特例2：调用abort函数退出程序执行时，不调用任何剩余对象的析构函数.</li></ul></li></ul><h3 id="小陷阱-私有数据成员的引用"><a href="#小陷阱-私有数据成员的引用" class="headerlink" title="小陷阱:私有数据成员的引用"></a>小陷阱:私有数据成员的引用</h3><p>考虑以下程序，是否出现类私有数据成员的引用情况？<br>如何解决该问题？（加const，如何加？）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    int &amp; setA() &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    A t;</span><br><span class="line">    int&amp; r = t.setA();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三行变为 <code>const int &amp; setA()</code>即可。</p><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><ul><li>By default, such assignment is performed by memberwise assignment(按成员赋值/逐个成员赋值). </li><li>拷贝构造函数在对还没存在的对象赋值时会调用；赋值函数在对已经存在的对象赋值会调用；赋值函数初始化前需要清理堆资源等，拷贝构造不需要。</li><li>注意点<ul><li>有一种特别常见的情况需要自己定义复制控制函数：类具有指针函数。</li><li>赋值操作符和复制构造函数可以看成一个单元，当需要其中一个时，我们几乎也肯定需要另一个</li><li>三法则：如果类需要析构函数，则它也需要赋值操作符和复制构造函数</li><li>如果没定义复制构造函数（别的不管），编译器会自动生成默认复制构造函数</li><li>如果定义了其他构造函数（包括复制构造函数），编译器绝不会生成默认构造函数</li><li>即使自己写了析构函数，编译器也会自动生成默认析构函数</li></ul></li><li>解决方案<br>  自定义拷贝构造函数：按引用传递</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>条件编译指令</li><li>访问成员函数的三种方式(句柄+操作符)</li><li>成员函数的作用域：class scope</li><li>访问函数和工具函数</li><li>带默认实参的构造函数</li><li>构造函数和析构函数被调用的顺序</li><li>破坏类的封装的一种做法：返回对私有数据成员的引用</li><li>利用一个对象初始化另一个对象(拷贝构造函数)</li></ul><h2 id="Chapter-10-类（2）"><a href="#Chapter-10-类（2）" class="headerlink" title="Chapter 10 类（2）"></a>Chapter 10 类（2）</h2><h3 id="常成员函数-1"><a href="#常成员函数-1" class="headerlink" title="常成员函数"></a>常成员函数</h3><ul><li>要求<ul><li>不能修改本对象的数据成员</li><li>不能调用本对象其它non-const成员函数</li></ul></li><li>建议<ul><li>所有不更改object成员的函数均声明为const成员函数</li></ul></li><li>注意<ul><li>成员函数是否为常成员函数，不仅取决于它不修改对象、不调用non-const成员函数，而且必须显式地声明为const！</li><li>构造函数、析构函数不能声明为const</li><li>可以调用非const成员函数初始化const对象（为什么？）<br>  对象的常量特性体现在初始化(构造)后、析构之前。</li></ul></li><li>小结<ul><li>可以定义const常量，具有不可变性；</li><li>便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患；</li><li>可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改；</li><li>可以保护被修饰的东西，防止意外的修改，增强程序的健壮性；</li><li>提高了效率（编译器对常量进行优化）</li></ul></li></ul><h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><p>构造函数初始化列表必须使用的情况 <em>注意：C++11支持const直接赋值。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const data member (例外?const static integer)(注：普通const必须一开始初始化)</span><br><span class="line">reference data member 引用类型的数据成员</span><br><span class="line">member objects, 数据成员是其他类(未提供缺省构造函数)的对象*</span><br><span class="line">继承类的基类base class*</span><br></pre></td></tr></table></figure></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul><li>成员对象的构造和析构顺序<ul><li>成员对象的构造先于宿主对象；</li><li>成员对象按照类定义中的声明顺序构造</li><li>成员对象的析构后于宿主对象。</li></ul></li><li>总结<ul><li>若无缺省构造函数，则必须使用初始化列表（思考原因）</li><li>若有缺省构造函数，此时如果成员对象没有显式通过成员初始化列表中初始化，则自动隐含调用缺省构造函数(default constructor).  性能方面？（避免双重初始化）</li><li>构造函数与析构函数的调用顺序</li><li>类的成员对象（public or private）<ul><li>把成员对象声明为public不会影响成员对象的封装性</li></ul></li></ul></li></ul><h3 id="友元函数与友元类"><a href="#友元函数与友元类" class="headerlink" title="友元函数与友元类"></a>友元函数与友元类</h3><ul><li>为什么使用友元<ul><li>为什么要使用友元函数</li><li>两个类要共享数据的时候</li><li>运算符重载的某些场合需要使用友元</li><li>使用友元函数可提高性能</li><li>用友元函数可以访问两个或多个类的私有数据，较其它方法使人们更容易理解程序的逻辑关系</li></ul></li><li>缺点:破环了类的封装机制</li><li>总结：<ul><li>类的友元函数在类作用域之外定义，但可以访问类的私有和保护成员</li><li>尽管类定义中有友元函数原型，友元函数仍然不是成员函数</li><li>由于友元函数不是任何类的成员函数，所以不能用句柄(对象)加点操作符来调用</li><li>public, private, protected成员访问符与友员关系的声明无关，因此友元关系声明可在类定义的任何位置，习惯上在类定义的开始位置</li><li>友元关系是指定的，不是获取的，如果让类B成为类A的友元类，类A必须显式声明类B为自己的友元类</li><li>友元关系不满足对称性和传递性</li><li>如果一个友元函数想与两个或更多类成为友元关系，在每个类中都必须声明为友元函数</li></ul></li></ul><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><ul><li>为什么使用<ul><li>直到运行时才能知道需要多少对象空间；</li><li>不知道对象的生存期到底有多长；</li><li>直到运行时才知道一个对象需要多少内存空间</li></ul></li><li>使用方法<ul><li>基本数据类型<ul><li><code>double *ptr = new double(3.14);</code></li><li><code>delete ptr</code></li></ul></li><li>类对象<ul><li><code>Cls *ptr = new Cls();</code></li><li><code>delete ptr;</code></li></ul></li><li>数组<ul><li><code>int *array = new int[size];</code></li><li><code>delete [] array;</code></li><li><code>Cls *clsarray = new Cls[size];</code></li><li><code>delete [] clsarray;</code></li></ul></li></ul></li></ul><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><ul><li>初始化<ul><li>显式初始化<ul><li>静态常量整数成员可在类定义中初始化（长整形/短整形/枚举）</li><li><code>const static int i = 0;</code> //ok</li><li>其它情况必须在类外部定义和初始化。</li><li><code>static int i = 0;</code> //error</li><li>const数组成员的初始化？*<br>  声明为const static数组，并在外部初始化</li></ul></li><li>未显示初始化<ul><li>静态基本类型的数据成员缺省初始化为0</li><li>静态抽象数据类型(类对象)的数据成员默认调用缺省构造函数</li><li>静态成员的空间分配并不在类的构造函数中完成，也不会在类的析构函数里完成空间回收</li></ul></li></ul></li><li>访问<ul><li>可直接通过类名+::访问</li><li>没有this指针（为什么？）<br>  static 成员函数独立于对象存在。而this指针必须指向类的具体的对象</li><li>不能加const（为什么？）<br>  const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针</li><li>可通过对象访问(public)，也可直接通过类名+::访问</li><li>不能访问非静态数据成员，也不能调用非静态成员函数</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>常量对象和常成员函数</li><li>对象的组合</li><li>友元函数和友元类</li><li>this指针(隐含参数，作用：级联调用)</li><li>动态内存分配</li><li>静态类成员</li></ul><h2 id="Chapter-11-运算符重载"><a href="#Chapter-11-运算符重载" class="headerlink" title="Chapter 11 运算符重载"></a>Chapter 11 运算符重载</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><ul><li>定义方式: <code>ClassName operator@([const ClassName&amp; A])</code></li><li>调用方式: <ul><li>普通函数<ul><li>全局函数: 函数名(参数列表)</li><li>类成员函数: 对象.函数名(参数列表)等</li></ul></li><li>重载的运算符<br>  使用时以表达式形式出现: HugeIntA + HugeIntB</li></ul></li><li>针对对象，三个不用重载的运算符：<ul><li>assignment operator (=) </li><li>address operators (&amp;) </li><li>comma operators (,) </li></ul></li><li>限制<ul><li>重载运算符应该仿效其相应的内置对象的功能</li><li>重载成的成员函数必须是非static的(带着问题思考)<br>  HugeInt operator+(const HugeInt&amp; a);</li><li>不能更改Precedence(优先级), Associativity(结合律) 以及 Number of Operands(操作数数目)</li><li>仅能重载现有运算符，不能创造新运算符</li></ul></li></ul><h3 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p>运算符函数可以是成员函数或者全局函数</p><ul><li>当重载为类的成员函数时<ul><li>非静态的类成员函数</li><li>使用this指针隐性获取操作左值</li><li>左操作数(或唯一的操作数)必须为该类对象(或对象引用)</li><li>将自动包含该类对象(或其引用)作为操作数，函数参数个数等于运算符目数-1</li></ul></li><li>当重载为全局函数时<ul><li>形式<pre><code>class HugeInt {    friend HugeInt operator+(const HugeInt &amp;, int);};</code></pre></li><li>函数参数个数等于运算符的目数</li><li>全局函数: 是否访问私有数据<ul><li>Friend（可访问私有数据）复习~~~</li><li>Non-friend</li></ul></li><li>思考：必须重载为全局函数的情况<ul><li>左操作数必须为不同类型对象或一个基本类型对象</li><li>使运算符具有可交换性<ul><li>HugeInteger + int 和 int + HugeInteger</li><li>成员函数+参数调换的全局函数</li></ul></li></ul></li></ul></li><li>设计原则<ul><li>( ), [ ], -&gt;和赋值(=, +=, -=等)运算符 <strong>必须</strong> 重载为成员函数</li><li>>>, &lt;&lt;和需要支持交换律(Commutative)的运算符重载为全局函数</li><li>其余运算符可以选择重载为成员或全局函数</li></ul></li></ul><h3 id="输入输出流运算符重载"><a href="#输入输出流运算符重载" class="headerlink" title="输入输出流运算符重载"></a>输入输出流运算符重载</h3><p>输出流重载 <code>friend ostream &amp;operator&lt;&lt;(ostream&amp;, const cls &amp;)</code><br>输入流重载 <code>friend istream &amp;operator&gt;&gt;(istream&amp;)</code></p><h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator!( ) const;</span><br><span class="line">&#125;;</span><br><span class="line">class String &#123;</span><br><span class="line">    friend bool operator!( const String &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h3><ul><li>带有一个参数的成员函数<br>  前提条件是仅当左操作数是该函数所在类的对象</li><li>带有二个参数的全局函数</li><li>其中一个参数必须是对象或对象引用<br>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator&lt;( const String &amp;) const;</span><br><span class="line">&#125;;</span><br><span class="line">class String &#123;</span><br><span class="line">    friend bool operator&lt;( const String &amp;, const String &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="运算符重载小结"><a href="#运算符重载小结" class="headerlink" title="运算符重载小结"></a>运算符重载小结</h3><ul><li><code>const Array &amp;operator=( const Array &amp; );</code><br>为何返回值要加&amp;和const？<ul><li>&amp;为了在a=(b=c)时提高性能</li><li>参数的&amp;为了防止自我复制</li><li>Const类型的返回值表示对相关对象的保护，实现禁左。禁止(a=b)=c</li></ul></li><li>虚悬指针（产生原因）与指针回收问题<br>  关于delete之后的指针使用（有的编译器可以访问，但会有潜在的错误）</li><li>通常会为任何一个使用动态分配内存的类同时提供一组函数（重要！）：<ul><li>复制构造函数</li><li>析构函数</li><li>重载的赋值运算符函数</li></ul></li><li>如何阻止类对象的复制<br>  将重载的赋值运算符以及拷贝构造函数设置为private</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>同类对象转换 ： 初始化对象,拷贝构造函数</li><li><p>非同类对象转换：</p><ul><li>转换构造函数</li><li>重载强制类型转换运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">函数声明形式</span><br><span class="line">    A::operator int() const; // 不需要返回值,不修改原对象</span><br><span class="line">    实现：A -&gt; int</span><br><span class="line">    A::operator OtherClass() const;</span><br><span class="line">    实现：A-&gt; OtherClass</span><br><span class="line"></span><br><span class="line">用户调用：</span><br><span class="line">     A s；</span><br><span class="line">     static_cast&lt;int&gt;(s);</span><br><span class="line">     static_cast&lt;OtherClass&gt;(s);</span><br><span class="line">编译器调用：</span><br><span class="line">s.operator int(); s.operator OtherClass();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>几个常用的cast<br>  dynamic_cast:   通常在基类和派生类之间转换时使用<br>  const_cast:   主要针对const和volatile的转换.<br>  static_cast:   一般的转换<br>  reinterpret_cast:   用于进行没有任何关联之间的转换，比如一个字符指针转换为一个整形数。</p></li><li>小结<ul><li>转换构造函数</li><li>重载强制类型转换运算符</li><li>隐式调用原则：<ul><li>先查找符合要求的函数</li><li>再调用转换运算</li><li>转换运算不能级联调用(仅能调用一次)</li></ul></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>哪些运算符可以重载？何时需要重载？有何限制？如何重载？<br>  “.”,”.*”,”::”,”?:”不能重载<br>  “=“,”&amp;”,”,”可以直接使用但有时也需要重载</li><li>成员函数 vs 全局函数</li><li>( ), [ ], -&gt;和赋值(=, +=, -=等)<br>  运算符必须重载为成员函数（有时函数需要被重载为常成员函数）<br>  支持交换律的运算符必须重载为全局函数</li><li>拷贝构造函数和转换构造函数</li><li>自定义String类 vs 标准string类</li></ul><h2 id="Chapter-12-继承"><a href="#Chapter-12-继承" class="headerlink" title="Chapter 12 继承"></a>Chapter 12 继承</h2><h3 id="is-a与has-a的区别"><a href="#is-a与has-a的区别" class="headerlink" title="is-a与has-a的区别"></a>is-a与has-a的区别</h3><ul><li>is-a代表继承<ul><li>一个类继承自另一个类</li><li>属于更加专有的一类对象</li><li>可以一个类继承一些行为，也可修改甚至创建新的行为<br>  例如vehicle类，有加速、减速等行为，car继承vehicle，同样有这些行为，也可以有新的行为（如打开后备箱等）</li></ul></li><li>has-a代表组合关系<ul><li>一个对象包含其它的成员对象<br>  例如Employee类中包含firstname、lastname、birthdate、hiredate等对象</li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>作用<ul><li>软件复用；</li><li>对事物进行分类；</li><li>支持软件的增量开发；</li><li>对概念进行组合。</li></ul></li><li>声明：<code>class &lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt; {……};</code>（多继承在后面添加）</li><li>访问规则<ul><li>派生类吸纳基类的数据成员及成员函数（隐性）</li><li>派生类的成员函数如何访问基类的数据成员和成员函数？(public继承)<ul><li>可以访问基类中的非private数据成员及成员函数</li><li>无法直接访问基类的private成员</li><li>可以通过基类中提供的非private成员函数实现对基类中private数据成员进行修改</li></ul></li><li>通常派生类需要重新定义一些成员函数，以实现派生类特有的功能及操作</li></ul></li><li>继承中的访问模式<ul><li>基类的public成员能够被程序中所有函数访问</li><li>基类的private成员只能被基类的成员函数和友元访问</li><li>基类的protected成员只能被基类的成员和友元以及派生类的成员和友元访问。<ul><li>注意：不能被类的实例（对象）访问。</li></ul></li><li>派生类如何访问基类的数据成员？<ul><li>默认情况：派生类成员简单地使用成员名就可以引用基类的public成员和protected成员。</li><li>当派生类重新定义了基类的成员函数时，访问方式：<br>  base-class name:: + 成员函数</li></ul></li><li>只要在派生类中重写基类的函数（函数名相同，即使参数不同），就无法默认调用基类的相关函数，此时基类中的函数需要“基类::函数名”来调用。</li></ul></li></ul><h3 id="派生类与基类的关系"><a href="#派生类与基类的关系" class="headerlink" title="派生类与基类的关系"></a>派生类与基类的关系</h3><ul><li>初始化<ul><li>如果派生类的构造函数没有显示调用基类的构造函数，C++将尝试隐式调用默认的构造函数（前提：基类需要有缺省的构造函数）</li><li>采用成员初始化器列表显示地初始化成员对象和调用基类的构造函数，可以防止重复初始化</li></ul></li><li><p>头文件:在派生类头文件中使用#include包含基类头文件</p><ul><li>告诉编译器基类的存在</li><li>让编译器根据类的定义确定对象的大小，派生类的对象大小取决于派生类显式定义的数据成员和继承自基类的数据成员</li><li>让编译器能够判断派生类是否正确的使用了基类的成员</li></ul></li><li><p>注意事项</p><ul><li>影响数据的有效性检查<br>  派生类可以直接访问基类的protected数据成员</li><li>派生类依赖于基类的实现<ul><li>基类的数据成员发生改变有可能影响派生类的实现</li><li>软件“易碎”或“脆弱”，不够健壮</li></ul></li><li>基类仅向派生类提供服务，则可使用protected类型声明，其他情况慎用protected</li></ul></li><li>在派生类中重定义基类成员<ul><li>通过调用基类的public成员函数来访问基类的私有数据成员</li><li>当功能相同时，尽量调用成员函数，以避免代码拷贝。</li><li>重定义基类成员函数时，一定要使用“::”访问基类成员，否则会引起无限递归，例如：earnings()</li><li>注意print()和earnings()的重新定义：调用基类的print()和earnings()函数<br>  符合软件工程要求：使用继承，通过调用成员函数隐藏了数据，保证了数据的一致性。</li></ul></li></ul><h3 id="基类、派生类中的构造与析构函数"><a href="#基类、派生类中的构造与析构函数" class="headerlink" title="基类、派生类中的构造与析构函数"></a>基类、派生类中的构造与析构函数</h3><ul><li>构造顺序<ul><li>建立派生类的实例对象时、必须调用基类的构造函数来初始化派生类对象的继承成员。</li><li>派生类的构造函数既可以隐式调用基类的构造函数，也可以在派生类的构造函数中通过给基类提供初始化值显式地调用。</li><li>基类构造函数-&gt;派生类构造函数</li></ul></li><li>析构顺序<br>  析构函数的调用顺序和构造函数的顺序相反，因此派生类的析构函数在基类析构函数之前调用。</li><li>包含成员对象的情况，假设基类和派生类都包含其他类的对象：<ul><li>在建立派生类的对象时，首先执行基类成员对象的构造函数，接着执行基类的构造函数，然后执行派生类的成员对象的构造函数，最后才执行派生类的构造函数。析构函数的调用次序与调用构造函数的次序相反。<br>  基类成员对象初始化—&gt;基类的构造函数—&gt;派生类成员对象初始化—&gt;派生类构造函数</li><li>建立成员对象的顺序是对象在类定义中的声明顺序。成员初始化器中的顺序不影响建立对象的顺序。   </li></ul></li></ul><h3 id="继承小结"><a href="#继承小结" class="headerlink" title="继承小结"></a>继承小结</h3><ul><li>公有继承<ol><li>基类成员对其对象的可见性：<br>公有成员可见，其他不可见。这里保护成员同于私有成员。</li><li>基类成员对派生类的可见性：<br>公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。</li><li>基类成员对派生类对象的可见性：<br>公有成员可见，其他成员不可见。<br>一定要区分派生类的对象和派生类中的成员函数对基类的访问是不同的。</li></ol></li><li>私有继承<ol><li>基类成员对其对象的可见性：<br>公有成员可见，其他成员不可见。（同前）</li><li>基类成员对派生类的可见性：<br>公有成员和保护成员可见，私有成员不可见。（同前）</li><li>基类成员对派生类对象的可见性：<br>所有成员都不可见。<br>保护继承与私有继承类似</li></ol></li><li>总结<br>  不论公有继承还是私有继承，基类成员对于派生类的访问权限是不变的。（可访问公有或保护类型成员）<br>  变化的是派生类的对象以及派生类的派生类对基类成员的访问权限。<br>  基类和派生类的定义<br>  Protected成员<br>  基类和派生类的关系：public，proteced，private<br>  继承关系中构造函数和析构函数顺序<br>  复合(has-a)和继承(is-a)的关系<br>  “使用”和”知道”</li></ul><h2 id="Chapter-13-多态"><a href="#Chapter-13-多态" class="headerlink" title="Chapter 13 多态"></a>Chapter 13 多态</h2><h3 id="面向对象三大要素"><a href="#面向对象三大要素" class="headerlink" title="面向对象三大要素"></a>面向对象三大要素</h3><pre><code>数据封装继承多态</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>解释1：同样的消息被类的不同对象接收时导致的完全不同的行为的一种现象。这里所说的消息即对类的成员函数的调用。 </li><li>解释2：通过指向派生类的基类指针，调用派生类的函数; 将不同的派生类对象都当作基类来处理，并根据对象不同产生不同的行为，以屏蔽各派生类对象之间的差异。写出通用的代码，使得程序员可以方便地处理普遍性问题。</li><li>C++语言支持两种类型的多态：<ul><li>编译时的多态(静态多态) ——函数重载</li><li>运行时的多态(动态多态) ——虚函数</li></ul></li><li>多态性提高了软件的可扩展性，使得可以用与接收消息对象类型无关的方式编写</li></ul><h3 id="继承中的对象关系"><a href="#继承中的对象关系" class="headerlink" title="继承中的对象关系"></a>继承中的对象关系</h3><ul><li>Invoking Base-Class Functions from Derived-Class Objects（基类指针指向派生类，调用基类函数）<br> 结论: 调用基类还是派生类的函数，取决于句柄的类型，而不是句柄指向的实际对象类型</li><li>Aiming Derived-Class Pointers at Base-Class Objects（派生类指针指向基类，错误）</li><li>Derived-Class Member-Function Calls via Base-Class Pointers（基类指针指向派生类，调用派生类函数，错误）<br>  结论: 通过对象句柄，仅能调用该句柄类型的成员函数<br>  解决办法: downcasting(dynamic_cast)</li></ul><h3 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>语法<ul><li>调用哪个(基类/派生类)虚函数，由对象类型而不是句柄类型决定.</li><li>虚函数用于继承结构中的基类和派生类，以实现多态.</li><li>派生类中覆盖(Overridden)的虚函数和基类中的虚函数必须函数签名和返回值均相同.<br>  包括函数名称、返回值、参数个数、类型、是否const都要一致</li></ul></li><li>调用虚函数的两种方式<ul><li>通过指向派生类的基类指针(或引用)调用，程序会在执行时(execution time)根据对象类型动态选择合适的派生类函数 – 动态绑定( dynamic binding )或延迟绑定( late binding ).</li><li>通过对象名和点操作符调用，程序在编译时(compile time)即根据对象类型确定函数– 静态绑定( static binding ).<ul><li>只有通过引用或指针来访问对象的虚函数时才进行动态绑定。</li><li>通过引用或指针访问对象的非虚成员函数，采用静态绑定。（与句柄类型的成员函数代码绑定）</li><li>通过“类名+::”访问对象成员函数，也采用静态绑定。</li><li>基类构造函数中对虚函数的调用不采用动态绑定。</li><li>通过指针访问其他成员函数并调用虚函数时仍需动态绑定。</li></ul></li></ul></li></ul><ul><li><p>限制</p><ul><li>只有类成员才能声明为虚函数</li><li>静态成员函数不能是虚函数</li><li>构造函数不能是虚函数</li><li><p>析构函数可以是虚函数，并且通常声明为虚函数(注意基类和派生类的析构函数不同名)<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commissionEmployeePtr = &amp;basePlusCommissionEmployee</span><br><span class="line">delete commissionEmployeePtr;</span><br></pre></td></tr></table></figure><p>调用的是basePlusCommissionEmployee的析构函数</p></li></ul></li></ul><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><ul><li>语法 : virtual void function() const <strong>= 0</strong>;</li><li>Abstract Class(抽象类): 包含一个或者多个纯虚函数的类。无法实例化(但可以声明指针和引用)，只能用于继承。<pre><code>Shape obj;              // ErrorRectangle objRectangle;Shape *ptr = &amp;objRectangle; // OKShape &amp;ref = objRectangle;  // OK</code></pre></li><li>作用：为派生类提供一个基本框架或公共接口。</li><li>Concrete Class(具体类): 不包含纯虚函数，可以实例化。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>成员函数是否声明为虚函数，取决于是否需要多态性支持</li><li>虚函数是否声明为纯虚函数，取决于该函数对于当前类是否有意义，以及当前类是否需要实例化</li></ul><h2 id="Chapter-14-模板"><a href="#Chapter-14-模板" class="headerlink" title="Chapter 14 模板"></a>Chapter 14 模板</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>利用一种完全通用的方法来设计函数或类而不必预先说明将被使用的每个对象的类型，利用模板功能可以构造相关的函数或类的系列，因此模板也可称为参数化的类型。——泛型编程（Generic Programming）</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>类模板(class template)和函数模板(function template)。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ul><li>声明<br>  template关键字+尖括号&lt;&gt;括起来的template parameter list（模板参数列表） </li><li>参数列表<ul><li>参数称为formal type parameter（形式类型参数）。在函数调用时替换为基本数据类型或用户自定义数据类型。</li><li>每个参数都必须以关键词typename （或class ）起头，参数和参数之间必须以逗号分隔，如 template &lt; typename T, typename V&gt;</li></ul></li><li>理解<ul><li>函数模板只是说明，不能直接执行，需要特化为模板函数后才能执行。  </li><li>处理过程<ul><li>在程序中说明了一个函数模板</li><li>编译系统发现有一个相应的函数调用<br>  例如：printArray( a, ACOUNT ); </li><li>编译器寻找和使用最符合函数名和参数类型的函数调用</li><li>根据实参中的类型来确认是否匹配函数模板中对应的形参，然后生成一个重载函数(函数模板特化)。（该重载函数的定义体与函数模板的函数定义体相同）</li><li>编译这个新建的函数</li></ul></li></ul></li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>允许有其它同名的函数模板，但参数不同</li><li>允许有其它同名的函数，但参数不同</li><li>编译器挑选最佳匹配的函数或模板<ul><li>编译器通过匹配过程确定调用哪个函数。</li><li>首先，编译器寻找和使用最符合函数名和参数类型的函数调用。如果找不到，则检查是否可以用函数模板产生符合函数名和参数类型的模板函数。</li><li>如果有多个函数和调用函数相匹配（且匹配程度相同），编译器会认为有二义性，将产生编译错误</li><li>如果没有找到符合函数，将考虑调用强制类型转换</li></ul></li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul><li><p>定义<br>  1、类模板通过允许将泛型类实例化为明确类型的类来实现软件复用<br>  2、类是对问题空间的抽象，而类模板则是对类的抽象，即更高层次上的抽象。<br>  3、程序中可以首先定义一个类模板，然后通过使用不同的实参生成不同的类。<br>  4、类模板的定义格式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename &lt;类型参数&gt;&gt; //模板声明</span><br><span class="line">class &lt;类名&gt;  // 类定义</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  5、每个“类型形参”前必须加typename or class关键字，对类模板进行实例化时，代表某种数据类型；也可以是普通数据类型形参，实例化时代表具体数据,如</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename arg1, int arg2, typename arg3&gt;</span><br><span class="line">class myclass</span><br><span class="line">　　&#123;  </span><br><span class="line">    arg1  buffer[arg2]；</span><br><span class="line">    arg3  x;　　//类的定义体</span><br><span class="line">　　&#125;；</span><br></pre></td></tr></table></figure><p>  6、类模板中成员函数可以放在类模板的定义体中(此时与类中的成员函数的定义方法一致)定义，也可以放在类模板的外部来定义，格式为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;类型形参表&gt;</span><br><span class="line">函数返回类型  类模板名&lt;类型名表&gt;::成员函数(形参)</span><br><span class="line">template &lt; typename arg1, int arg2, typename arg3&gt;</span><br><span class="line">void myclass&lt;arg1,arg2,arg3&gt;::print() &#123;&#125;</span><br></pre></td></tr></table></figure><p>  7、</p><ul><li>类模板定义只是对类的描述，它本身还不是一个实实在在的类。</li><li>类模板不能直接使用，必须先特化（specialized）为相应的模板类，定义模板类的对象(即实例)后，才可使用(创建对象等)。</li><li>可以用以下方式创建类模板的特化及对象。<br>  类模板名&lt;类型实参表&gt; 对象名表；<br>  如：Myclass<int> a;<br>  此处的&lt;类型实参表&gt;要与该模板中的&lt;类型形参表&gt;匹配，要具有同样的顺序和类型，否则会产生错误！ </int></li></ul></li></ul><h3 id="非类型参数和类模板的缺省类型"><a href="#非类型参数和类模板的缺省类型" class="headerlink" title="非类型参数和类模板的缺省类型"></a>非类型参数和类模板的缺省类型</h3><ul><li><p>非类型的模板形参</p><ul><li>特化时作为常量对待</li><li>可以有缺省参数</li><li>Example:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Template header:   </span><br><span class="line">template&lt; typename T, int elements = 10 &gt;</span><br><span class="line">Declaration: Stack&lt; double, 100 &gt; salesFigures;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型形参也可以有默认实参<br>  Example</p><pre><code>Template header:   template&lt; typename T = string &gt;Declaration:   Stack&lt;&gt; jobDescriptions;</code></pre></li><li><p>Explicit specializations(显式特化)</p><ul><li>当某一特殊数据类型不能使用通用类模板时，可以定制处理(即：重定义该类型的类模板。)</li><li>显式特化：<br>  Stack&lt; Employee &gt; specialization<br>  template&lt;&gt;<br>  class Stack&lt; Employee &gt;{…};<br>完全代替了通用类模板 Stack&lt; Employee &gt;<br>没有使用原来类模板的任何内容，甚至可以包含不同的成员</li><li>优点：可以兼容已有的基于模板的操作</li></ul></li></ul><h3 id="函数模板与友元函数"><a href="#函数模板与友元函数" class="headerlink" title="函数模板与友元函数"></a>函数模板与友元函数</h3><ul><li>函数声明为类模板的每一个特化的友元<br>  <code>friend void f1();//无参数</code><br>  f1 is a friend of X&lt; double &gt;, X&lt; string &gt;, etc. </li><li>函数声明为类模板的某一类型参数特化的友元<br>  <code>friend void f2( X&lt; T &gt; &amp; );//带参数</code><br>  f2( X&lt; float &gt; &amp; ) is a friend of X&lt; float &gt; but not a friend of X&lt; string &gt;</li><li>另一个类的成员函数可以声明为类模板每一个特化的友元（无参数）<br>  <code>friend void A::f3();</code><br>  f3 of class A is a friend of X&lt; double &gt;, X&lt; string &gt;, etc. </li><li>另一个类的成员函数可以声明为类模板某个类型参数特化的友元（带参数）<br>  <code>friend void C&lt; T &gt;::f4( X&lt; T &gt; &amp; );</code><br>  C&lt; float &gt;::f4( X&lt; float &gt; &amp; ) is a friend of X&lt; float &gt; but not a friend of X&lt; string &gt;</li><li>另一个类可以声明为类模板的每一个特化的友元<br>  <code>friend class Y;</code>（无类型参数）<br>  Every member function of class Y is a friend of X&lt; double &gt;, X&lt; string &gt;, etc. </li><li>另一个类可以声明为类模板的某个类型参数特化的友元<br>  <code>friend class Z&lt; T &gt;;</code>（有类型参数）<br>  Class-template specialization Z&lt; float &gt; is a friend of X&lt; float &gt;, Z&lt; string &gt; is a friend of X&lt; string &gt;, etc.</li></ul><h3 id="函数模板与static"><a href="#函数模板与static" class="headerlink" title="函数模板与static"></a>函数模板与static</h3><ul><li>从类模板实例化的每个模板特化有自己的static数据成员</li><li>该模板特化的所有对象共享一个static数据成员</li><li>static数据成员必须被定义，在文件范围内被初始化</li><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;    static int x；</span><br><span class="line">&#125;；</span><br><span class="line"> template &lt; typename T&gt; int A&lt;T&gt;::x=0;</span><br><span class="line"> A&lt;int&gt; a1,a2; // a1和a2共享一个x</span><br><span class="line"> A&lt;double&gt; b1,b2; // b1和b2共享一个x</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>模板与继承的区别<br>  当对象的类型不影响类中函数的行为时，就要使用模板来生成这样一组类。<br>  当对象的类型影响类中函数的行为时，就要使用继承来得到这样一组类。 </li><li>函数模板和函数模板重载</li><li>类模板</li><li>定义</li><li>类型参数和非类型参数</li><li>实例创建</li><li>模板和继承</li><li>模板和友元</li><li>模板中的静态成员</li></ul><h2 id="Chapter-16-异常处理"><a href="#Chapter-16-异常处理" class="headerlink" title="Chapter 16 异常处理"></a>Chapter 16 异常处理</h2><h3 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h3><ul><li>C++提供了一些内置的语言特性来抛出（throw）异常，用以通知“异常已经发生”，然后由预先安排的程序段来捕获（catch）异常，并对它进行处理。</li><li><p>捕获并处理异常的程序段</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">   &#123;复合语句&#125;</span><br><span class="line">catch（异常类型声明1）</span><br><span class="line">    &#123;复合语句&#125;</span><br><span class="line">catch（异常类型声明2）</span><br><span class="line">    &#123;复合语句&#125;</span><br><span class="line">    …</span><br></pre></td></tr></table></figure></li><li><p>流程解释</p><ul><li>将可能抛出异常的程序段嵌在try块之中，并通过throw操作创建一个异常对象并抛掷。</li><li>如果此时没有引起异常，程序从try块后跟随的最后一个catch子句后面的语句继续执行下去。</li><li>如果存在异常，顺序检查try块后面的catch子句，匹配的catch子句将捕获并处理异常（或继续抛掷异常）。</li><li>如果匹配的处理器未找到，则默认调用terminate函数，其缺省功能是调用abort终止程序。<h3 id="标准库异常类"><a href="#标准库异常类" class="headerlink" title="标准库异常类"></a>标准库异常类</h3></li></ul></li><li><p>C++标准库提供的逻辑异常：</p><ul><li>invalid_argument异常，接收到一个无效的实参，抛出该异常。</li><li>out_of_range异常，收到一个不在预期范围中的实参，则抛出。</li><li>length_error异常，报告企图产生“长度值超出最大允许值”的对象</li><li>domain_error异常，用以报告域错误（domain error）。</li></ul></li><li><p>C++标准库提供的运行时异常（）</p><ul><li>range_error异常，报告内部计算中的范围错误。</li><li>overflow_error异常，报告算术溢出错误。</li><li>underflow_error异常，报告算术下溢错误。</li><li>以上三个异常是由runtime_error类派生的。</li><li>bad_alloc异常。当new()操作符不能分配所要求的存储区时，会抛出该异常。它是由基类exception派生的。</li></ul></li><li><p>exception类接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace std&#123; //注意在名字空间域std中</span><br><span class="line">  class exception&#123;</span><br><span class="line">  public:</span><br><span class="line">    exception()  throw() ; //默认构造函数</span><br><span class="line">    exception(const exception &amp;)  throw() ; //复制构造函数</span><br><span class="line">    exception &amp;operator=(const exception&amp;) throw() ;</span><br><span class="line">     //复制赋值操作符</span><br><span class="line">    virtual ~exception()  throw() ; //析构函数</span><br><span class="line">    virtual const char* what() const  throw() ; </span><br><span class="line">    //返回一个C风格的字符串，目的是为抛出的异常提供文本描述</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="catch语句详解"><a href="#catch语句详解" class="headerlink" title="catch语句详解"></a>catch语句详解</h3><ul><li>catch子句由三部分组成：关键字catch、圆括号中的异常声明以及复合语句中的一组语句。</li><li>catch子句不是函数，所以圆括号中不是形参，而是一个异常类型声明，可以是类型也可以是对象。</li><li>catch子句的使用：由系统按抛出的异常类型自动在catch子句列表中匹配(找寻能够处理的第一个catch处理器)。（类型相同或是继承类）</li><li>catch子句可以包含返回语句（return），也可不包含返回语句。包含返回语句，则整个程序结束。不包含返回语句，则执行最后一个catch处理器之后的下一条语句（不会回到异常发生点）。</li><li>如果没有异常发生，继续执行try块中的代码，与try块相关联的catch子句被忽略，程序正常执行</li><li>注意<ul><li>try与catch间不能添加其他代码</li><li>一个catch处理器只能有一个参数</li><li>在try语句后两个不同catch处理器中捕获相同异常类型——错误！</li><li>通过引用捕获异常对象，能够去除表示抛出的异常对象的复制开销</li></ul></li><li>catch(…){ /<em>代码</em>/ } // catch_all子句<ul><li>任何异常都可以进入这个catch子句。这里的三个点称为省略号。花括号中的复合语句用来执行指定操作。</li><li>catch_all子句可以单独使用，也可以与其它catch子句联合使用。如果联合使用，它必须放在相关catch子句表的最后。</li><li>如果catch_all子句放在前面进行某项操作，则其它的操作应由catch子句重新抛出异常，逆调用链去查找新的处理子句来处理。</li></ul></li></ul><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><ul><li>当catch语句捕获一个异常后，可能无法处理或不能完全处理异常，完成某些操作后，该异常必须由函数链中更上级（更外层）的函数来处理，这时catch子句可以重新抛出（throw;）该异常，把异常传递给函数调用链中更上级的另一个catch子句，由它进行进一步处理。</li><li>throw；//异常的再抛出<ul><li>由其外层的catch捕获</li><li>外层无catch处理器时，编译器调用terminate终止程序</li></ul></li></ul><h3 id="异常指定"><a href="#异常指定" class="headerlink" title="异常指定"></a>异常指定</h3><ul><li><code>int someFunction( double value ) throw (a, b, c) {// fun body}</code></li><li>异常指定：列出函数可抛出的异常<ul><li>函数可抛出指定异常或派生类型</li><li>当函数抛出异常不在异常指定中，调用C++标准库的unexpected函数</li></ul></li><li>不带异常指定的函数可以抛出任何异常<ul><li>void g();</li></ul></li><li>如果异常指定为throw()，表示该函数不抛出异常。</li><li>抛出一个函数异常规格中未声明的异常或者包括空异常规格下抛出异常，将由unexpected()处理</li><li>虚函数中的异常指定<br>  派生类的虚函数的异常指定必须与基类虚函数的异常一样或更严格。因为当派生类的虚函数被指向基类类型的指针调用时，保证不会违背基类成员函数的异常规范。<br>  例子：<pre><code>class CBase{public:  virtual int fun1(int)  throw();  virtual int fun2(int)  throw(int);  virtual string fun3()   throw(int,string);};class CDerived:public CBase{public:  int fun1(int)  throw(int);  //错！异常规范不如throw()严格  int fun2(int)  throw(int);  //对！有相同的异常规范  string fun3()  throw(string); }  //对！异常规范比  throw(int,string)更严格}</code></pre></li></ul><h3 id="unexpected"><a href="#unexpected" class="headerlink" title="unexpected"></a>unexpected</h3><blockquote><p>unexpected()调用set_unexpected() 指定的函数<br>    set_unexpected 定义在 &lt;exception></p><blockquote><p>如果set_unexpected() 未指定被调用函数，默认情况下，terminate()被调用<br>    terminate定义在&lt;terminate><br>    terminate()调用set_terminate()指定的函数<br>如果set_terminate()未指定被调用函数，默认调用abort()，退出程序，不会释放内存，导致资源泄漏<br>    函数set_terminate和set_unexpected取函数指针为参数。每个参数指向返回类型为void和无参数的函数。</p></blockquote></blockquote><h3 id="栈展开-stack-unwinding"><a href="#栈展开-stack-unwinding" class="headerlink" title="栈展开(stack unwinding)"></a>栈展开(stack unwinding)</h3><ul><li>概念：因发生异常而逐步退出复合语句和函数定义的过程。</li><li>具体过程<ul><li>当异常被抛出但没有在特定的域内被捕获时，该函数调用堆栈将展开，并试图在下一个外部try-catch语句中处理</li><li>展开函数调用堆栈意味着在调用链中没有捕获异常的函数将会终止执行，并控制返回到最初调用该函数的语句中</li><li>如果该调用语句被一个try语句包含，则试图捕获该异常；否则堆栈展开将继续发生</li><li>如果在main函数中仍没有找到匹配的Handler, 则调用terminate函数(该函数缺省调用abort, 不执行栈展开), 结束程序.</li><li>每抛出一个异常，首先找到能捕获处理该异常的catch块；</li><li>利用throw语句中的”实参”对相应的”catch”块的“形参”进行初始化；</li><li>检查从抛出异常的try块首到throw之间已进行构造但尚未析构的那些处于堆栈中的局部对象，自动进行退栈和析构处理。</li></ul></li><li>注意点<ul><li>在栈展开期间，在退出的域中有某个局部量是类对象，栈展开过程将自动调用该对象的析构函数，完成资源的释放。</li><li>特别说明：由堆栈展开而调用的析构函数抛出了异常，那么terminate将被调用</li><li>调用terminate函数的情况：<ul><li>对于抛出的异常，异常机制找不到匹配的catch块</li><li>析构函数试图在堆栈展开时抛出异常</li><li>在没有异常要处理时试图重新抛出异常</li><li>调用函数unexpected将默认调用函数terminate</li></ul></li><li>在调用terminate函数时，函数set_terminate可以指定被调用的函数。否则默认调用abort函数（不会对自动或静态存储类对象调用析构函数）</li></ul></li></ul><h3 id="构造、析构函数与异常处理"><a href="#构造、析构函数与异常处理" class="headerlink" title="构造、析构函数与异常处理"></a>构造、析构函数与异常处理</h3><ul><li>异常处理抛出前为try语句块中构造的所有局部对象自动调用析构函数</li><li>如果一个对象包含成员对象，且在外部对象完全构造前抛出了异常，那么异常出现之前构造的成员对象将被析构</li><li>如果在异常发生时数组对象只部分构造，则只有已构造的部分被析构</li></ul><h3 id="继承与异常处理"><a href="#继承与异常处理" class="headerlink" title="继承与异常处理"></a>继承与异常处理</h3><p>如果catch捕获基类类型异常对象的指针或引用，则可以捕获该基类所派生的异常对象的指针或引用。这样允许多态处理错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;   ……</span><br><span class="line">    throw Cdrived;</span><br><span class="line">&#125;</span><br><span class="line">catch (Cbase &amp; base)</span><br><span class="line">     &#123;base.DoSomething();&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new与异常处理"><a href="#new与异常处理" class="headerlink" title="new与异常处理"></a>new与异常处理</h3><ul><li>Function set_new_handler<ul><li>函数参数为没有参数没有返回值的函数指针</li><li>一旦注册了new处理器，则不会抛出bad_alloc</li></ul></li><li>C++标准指出new处理器需要完成以下任务的一个<ul><li>通过释放其他动态分配的内存，再次尝试分配</li><li>抛出bad_alloc异常</li><li>调用函数abort或exit结束程序</li></ul></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>异常的概念</li><li>try…throw…catch模块的语法和处理流程</li><li>栈展开过程（与构造和析构的关系）</li><li>对其它异常的处理方法<ul><li>new异常的处理</li><li>动态内存分配异常的处理</li></ul></li></ul><h2 id="Chapter-17-文件"><a href="#Chapter-17-文件" class="headerlink" title="Chapter 17 文件"></a>Chapter 17 文件</h2><h3 id="文件的基本概念"><a href="#文件的基本概念" class="headerlink" title="文件的基本概念"></a>文件的基本概念</h3><ul><li>本节中文件指的是磁盘文件。C++文件（file）分为两类：文本文件和二进制文件。</li><li>文本文件由字符序列组成，也称ASCII码文件，在文本文件中存取的最小信息单位为字符（character）</li><li>二进制文件中存取的最小信息单位为字节（Byte），如.obj</li><li>C++把每一个文件都看成一个有序的字节流，每一个文件或者以文件结束符（EOF）结束，或者在特定的字节号处结束。 </li><li>Bits (二进制位)<ul><li>0 or 1</li><li>计算机支持的最小数据项</li><li>计算机电路执行位处理</li><li>所有数据项最终由位组成</li></ul></li><li>Characters(字符)<ul><li>数字、字母和专门的符号称为“字符”</li><li>能够在特定计算机上用来编写程序和代表数据项的所有字符的集合称为“字符集”</li><li>Char以字节形式存储 (8 bits)</li><li>Wchar_t 占多个字节(用于非英文字符集的表示)</li></ul></li><li>Fields(字段或数据项)<ul><li>由字符组成</li><li>代表一定的含义</li><li>Example：姓名，颜色等等</li></ul></li><li>Records(记录)<ul><li>由多个字段组成</li><li>C++中表现为：类</li><li>Example<br>  An employee’s record might include id#, name, address, etc.<br>  记录的关键字：A record key is a field unique to each record</li></ul></li></ul><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><ul><li>当打开一个文件时，该文件就和某个流关联起来了。对文件进行读写实际上受到一个文件定位指针（file position pointer）的控制。</li><li>输入流的指针也称为读指针，每一次提取操作将从读指针当前所指位置开始，每次提取操作自动将读指针向文件尾移动。</li><li>输出流指针也称写指针，每一次插入操作将从写指针当前位置开始，每次插入操作自动将写指针向文件尾移动。</li><li>为了在C++中执行文件处理，必须包含头文件<code>&lt;iostream&gt;和&lt;fstream&gt;</code></li></ul><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><p>必须包含头文件：</p><p>#include <fstream></fstream></p><p><fstream>包括三种类模板的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basic_ifstream (for file input)</span><br><span class="line">basic_ofstream (for file output) </span><br><span class="line">basic_fstream (for file input and output)</span><br></pre></td></tr></table></figure></fstream></p><p>提供了处理字符流的模板特化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream:从文件中读入字符(读文件)</span><br><span class="line">ofstream:向文件输出字符(写文件)</span><br><span class="line">fstream：支持文件中字符的输入和输出</span><br></pre></td></tr></table></figure></p><p>生成这些流类模板特化的对象，即可打开文件<br>程序和文件之间通过流对象交互</p><p>写数据到文件</p><ul><li>创建ofstream对象</li><li>构造函数ofstream(const char* filename,int mode) <pre><code>filename：文件名由文件的主名和扩展名两部分组成。mode：ios::out ：缺省模式，覆盖文件中已有数据ios::app：向文件末尾添加数据例：ofstream outClientFile( &quot;clients.dat&quot;, ios::out );建立了一个到文件的“通信通道” 如果该文件名不存在，则新建一个同名文件</code></pre></li><li><p>对于已创建的文件对象，使用成员函数打开文件</p><ul><li>与构造函数的参数相同，可以先创建再打开</li><li>例：<code>ofstream outClientFile；</code><pre><code>`outClientFile.open(&quot;clients.dat“, ios::out);`</code></pre><img src="/2018/06/05/c-review/ios.jpg" title="Mode表">说明<br>in ：(从文件读取) 打开方式只要含in，如文件不存在则返回失败。在打开为输入输出方式时（同时用out），编程应注意判断是否失败，失败时千万不可再写入文件。<br>out： (写入文件) 如文件不存在，则建立新文件，如文件存在，如果同时未设定app, in，则文件清空。<br>trunc：（打开文件，并清空它）文件不存在则建立新文件，与out默认操作相同。但与in配合，文件不存在则返回失败。<br>app：(写入文件，添加在末尾)原文件内容保留，新数据接在尾部。<br>ate: (at end，打开文件，文件指针在文件尾) 文件指针可以移动，即新数据可写到任何位置。文件是否清空由其它标识决定。<br> trunc/app/ate最好配合out、in等一起用，因为不同的C++平台，要求不同，一起用不会出错。如不一起用，至少VC++不认这种格式。<br>  binary标识以二进制方式打开文件。同时用out时，如文件不存在，则建立新文件，并且新文件能用，不必清状态字。</li></ul></li><li><p>既输入又输出 </p><ul><li>fstream iofile； </li><li>iofile.open(“myfile.txt”,ios::in|ios::out);</li></ul></li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><ul><li>打开文件时应该判断是否成功，若成功，文件流对象值为非零值，不成功为0（NULL），文件流对象值就是指它的地址。</li></ul><ol><li>说明一个文件流对象，这又被称为内部文件：<br> ifstream ifile；//只输入用<br> ofstream ofile；//只输出用<br> fstream iofile；//既输入又输出用 </li><li>使用文件流对象的成员函数打开一个磁盘文件。<br> iofile.open(“myfile.txt”,ios::in|ios::out);<br> 也可直接通过构造函数打开文件：<br> fstream iofile(”myfile.txt”,ios::in|ios::out);</li><li>使用提取(&gt;&gt;)和插入(&lt;&lt;)运算符对文件进行读写操作，或使用成员函数(get\put)进行读写。</li><li>关闭文件。三个文件流类各有一个关闭文件的成员函数 :<br> void ifstream::close();<br> void ofstream::close();<br> void fstream::close();<br> 使用很方便，如：iofile.close();</li></ol><ul><li><p>文件关闭</p><ul><li>关闭文件时，系统把该文件相关联的文件缓冲区中的数据写到文件中，保证文件的完整，收回与该文件相关的内存空间，把磁盘文件名与文件流对象之间的关联断开，可防止误操作修改了磁盘文件。</li><li>关闭文件并没有取消文件流对象，该文件流对象又可与其他磁盘文件建立联系。文件流对象在程序结束时，或它的生命期结束时，由析构函数撤消。它同时释放内部分配的预留缓冲区。 </li><li>调用析构函数也会关闭相应正在打开的文件</li></ul></li><li><p>在Windows平台下如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的”\r\n”转换成”\n”；当写入文件的时候，系统会将”\n”转换成”\r\n”写入。如果以”二进制”方式打开文件，则读/写都不会进行这样的转换。</p></li><li><p>文件定位指针：<br>  文件中下一个被读取或写入的字节号<br>  istream、ostream都提供了修改文件定位指针的成员函数<br>  seekg(long pos, int mode)—istream<br>  seekp(long pos, int mode)—ostream</p></li></ul><h3 id="规范化操作"><a href="#规范化操作" class="headerlink" title="规范化操作"></a>规范化操作</h3><ul><li>在面向对象的程序设计中，信息总是放在对象的数据成员里。这些信息最终需要保存到文件中。</li><li>读取文件中对象的信息时，必须重新创建对象，把数据读入对象，在运行过程中，对放在对象的数据成员里的信息利用和修改，运行结束时必须把这些信息重新保存到文件中，然后关闭文件</li><li>在面向对象的C++程序设计中，文件应该在构造函数中打开，并创建对象；而在析构函数中保存和关闭文件，并撤销对象。</li></ul><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>文件流分为三种<ul><li>文件输入流(ifstream), 文件输出流(ofstream),文件输入/输出流(fstream)</li><li>文件处理步骤</li><li>定义文件流对象</li></ul></li><li>打开文件<br><code>void open(const unsigned char *filename, int mode, int access=filebuf::openprot)；</code></li><li><p>关闭文件</p><ul><li>调用成员函数close() </li></ul></li><li><p>常用操作</p><ul><li>sfile.unsetf(ios::skipws);//把跳过空格控制位置0,即不跳过空格,否则空格全部未复制</li><li><img src="/2018/06/05/c-review/fun.jpg" title="常用函数"></li></ul></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><a href="/2018/06/05/c-review/all.zip" title="点击下载所有作业">点击下载所有作业</a><p>建议研究13章（week9）、17章作业</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;期末复习总览&quot;&gt;&lt;a href=&quot;#期末复习总览&quot; class=&quot;headerlink&quot; title=&quot;期末复习总览&quot;&gt;&lt;/a&gt;期末复习总览&lt;/h1&gt;&lt;h2 id=&quot;占比分布&quot;&gt;&lt;a href=&quot;#占比分布&quot; class=&quot;headerlink&quot; title=&quot;占
      
    
    </summary>
    
      <category term="期末复习" scheme="http://www.zjdx1998.ml/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="期末复习" scheme="http://www.zjdx1998.ml/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="C++" scheme="http://www.zjdx1998.ml/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018ACM-ICPC江苏邀请赛（徐州）参赛总结</title>
    <link href="http://www.zjdx1998.ml/2018/06/03/18-6-icpcjsxz/"/>
    <id>http://www.zjdx1998.ml/2018/06/03/18-6-icpcjsxz/</id>
    <published>2018-06-03T15:10:19.000Z</published>
    <updated>2018-06-03T16:22:50.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="校园环境"><a href="#校园环境" class="headerlink" title="校园环境"></a>校园环境</h1><h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><img src="/2018/06/03/18-6-icpcjsxz/pic1.jpg" title="Library"><img src="/2018/06/03/18-6-icpcjsxz/pic2.jpg" title="Library"><img src="/2018/06/03/18-6-icpcjsxz/pic3.jpg" title="Building"><h2 id="比赛体育馆外景"><a href="#比赛体育馆外景" class="headerlink" title="比赛体育馆外景:"></a>比赛体育馆外景:</h2><img src="/2018/06/03/18-6-icpcjsxz/pic4.jpg" title="体育馆"><h2 id="比赛体育馆内景"><a href="#比赛体育馆内景" class="headerlink" title="比赛体育馆内景:"></a>比赛体育馆内景:</h2><img src="/2018/06/03/18-6-icpcjsxz/pic5.jpg" title="体育馆"><h1 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h1><h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><img src="/2018/06/03/18-6-icpcjsxz/A.jpg" title="A"><h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><img src="/2018/06/03/18-6-icpcjsxz/B.jpg" title="B"><h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><img src="/2018/06/03/18-6-icpcjsxz/C.jpg" title="C"><h2 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h2><img src="/2018/06/03/18-6-icpcjsxz/D.jpg" title="D"><h2 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h2><img src="/2018/06/03/18-6-icpcjsxz/E.jpg" title="E"><h2 id="F题"><a href="#F题" class="headerlink" title="F题"></a>F题</h2><img src="/2018/06/03/18-6-icpcjsxz/F.jpg" title="F"><h2 id="G题"><a href="#G题" class="headerlink" title="G题"></a>G题</h2><img src="/2018/06/03/18-6-icpcjsxz/G.jpg" title="G"><h2 id="H题"><a href="#H题" class="headerlink" title="H题"></a>H题</h2><img src="/2018/06/03/18-6-icpcjsxz/H.jpg" title="H"><h2 id="I题"><a href="#I题" class="headerlink" title="I题"></a>I题</h2><img src="/2018/06/03/18-6-icpcjsxz/I.jpg" title="I"><h2 id="J题"><a href="#J题" class="headerlink" title="J题"></a>J题</h2><img src="/2018/06/03/18-6-icpcjsxz/J.jpg" title="J"><h2 id="K题"><a href="#K题" class="headerlink" title="K题"></a>K题</h2><img src="/2018/06/03/18-6-icpcjsxz/K.jpg" title="K"><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><a href="/2018/06/03/18-6-icpcjsxz/solution.pdf" title="zkc题解">zkc题解</a><a href="/2018/06/03/18-6-icpcjsxz/code.zip" title="标程汇总">标程汇总</a><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="金牌队"><a href="#金牌队" class="headerlink" title="金牌队"></a>金牌队</h2><img src="/2018/06/03/18-6-icpcjsxz/gold.jpg" title="金牌队"><h2 id="lcl是SEU的红太阳"><a href="#lcl是SEU的红太阳" class="headerlink" title="lcl是SEU的红太阳"></a>lcl是SEU的红太阳</h2><img src="/2018/06/03/18-6-icpcjsxz/silver.jpg" title="lcl是SEU的红太阳"><h2 id="lcl领奖图"><a href="#lcl领奖图" class="headerlink" title="lcl领奖图"></a>lcl领奖图</h2><img src="/2018/06/03/18-6-icpcjsxz/lcl.jpg" title="lcl领奖图"><h2 id="奖牌"><a href="#奖牌" class="headerlink" title="奖牌"></a>奖牌</h2><img src="/2018/06/03/18-6-icpcjsxz/medal.jpg" title="难过的CU"><h2 id="最终榜单"><a href="#最终榜单" class="headerlink" title="最终榜单"></a><a href="http://ctec.cumt.edu.cn/acmboard2018" target="_blank" rel="noopener">最终榜单</a></h2><h2 id="比赛官网"><a href="#比赛官网" class="headerlink" title="比赛官网"></a><a href="http://acm.cumt.edu.cn" target="_blank" rel="noopener">比赛官网</a></h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>四支队伍，一银一铜两铁，我们队卡了两题，如果后来我能及时意识到矩阵快速幂可能还能及时A掉I题，不会这么惨。</p><h2 id="乱入的自拍"><a href="#乱入的自拍" class="headerlink" title="乱入的自拍"></a>乱入的自拍</h2><img src="/2018/06/03/18-6-icpcjsxz/zp1.jpg" title="自拍"><img src="/2018/06/03/18-6-icpcjsxz/zp2.jpg" title="自拍"><img src="/2018/06/03/18-6-icpcjsxz/zp3.jpg" title="自拍">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;校园环境&quot;&gt;&lt;a href=&quot;#校园环境&quot; class=&quot;headerlink&quot; title=&quot;校园环境&quot;&gt;&lt;/a&gt;校园环境&lt;/h1&gt;&lt;h2 id=&quot;图书馆&quot;&gt;&lt;a href=&quot;#图书馆&quot; class=&quot;headerlink&quot; title=&quot;图书馆&quot;&gt;&lt;/a&gt;图书
      
    
    </summary>
    
      <category term="ACM" scheme="http://www.zjdx1998.ml/categories/ACM/"/>
    
    
      <category term="ACM" scheme="http://www.zjdx1998.ml/tags/ACM/"/>
    
      <category term="数学" scheme="http://www.zjdx1998.ml/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵快速幂" scheme="http://www.zjdx1998.ml/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="可持久化线段树" scheme="http://www.zjdx1998.ml/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="dp" scheme="http://www.zjdx1998.ml/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>5月下旬ACM训练记录</title>
    <link href="http://www.zjdx1998.ml/2018/05/17/ACM-Training/"/>
    <id>http://www.zjdx1998.ml/2018/05/17/ACM-Training/</id>
    <published>2018-05-17T03:23:06.000Z</published>
    <updated>2018-06-03T15:28:23.880Z</updated>
    
    <content type="html"><![CDATA[<p>题解在题目名链接的代码中查看</p><h1 id="Codeforces"><a href="#Codeforces" class="headerlink" title="Codeforces"></a>Codeforces</h1><table><thead><tr><th>序号</th><th>题目名</th><th>所属比赛</th><th>算法</th><th>做出/补题</th><th>做题时间</th></tr></thead><tbody><tr><td><center> 1 </center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44A.cpp" title="A.Chess Placing">A.Chess Placing</a></center></td><td><center>ECF Round 44</center></td><td><center>模拟</center></td><td><center> √ </center></td><td><center>2018/5/21 </center></td></tr><tr><td><center>2</center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44B.cpp" title="B.Switches and Lamps">B.Switches and Lamps</a>   </center></td><td><center> ECF Round 44</center></td><td><center>模拟</center></td><td><center> √ </center></td><td><center>2018/5/21 </center></td></tr><tr><td><center>3</center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44C.cpp" title="C.Liebig's Barrels">C.Liebig's Barrels</a>   </center></td><td><center> ECF Round 44</center></td><td><center>贪心</center></td><td><center> √ </center></td><td><center>2018/5/21 </center></td></tr><tr><td><center>4</center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44D.cpp" title="D.Sand Fortress">D.Sand Fortress</a>   </center></td><td><center> ECF Round 44</center></td><td><center>二分</center></td><td><center> × √</center></td><td><center>2018/5/23 </center></td></tr><tr><td><center>5</center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44E.cpp" title="E.Pencils and Boxes">E.Pencils and Boxes</a>   </center></td><td><center> ECF Round 44</center></td><td><center>dp+树状数组</center></td><td><center> × √</center></td><td><center>2018/5/24 </center></td></tr><tr><td><center>6</center></td><td><center> <a href="/2018/05/17/ACM-Training/ecfr44F.cpp" title="F.Isomorphic Strings">F.Isomorphic Strings</a>   </center></td><td><center> ECF Round 44</center></td><td><center>字符串Hash</center></td><td><center> × √</center></td><td><center>2018/5/24 </center></td></tr><tr><td><center>7</center></td><td><center>    </center></td><td><center> ECF Round 44</center></td><td><center></center></td><td><center> × </center></td><td><center>2018/5/21 </center></td></tr></tbody></table><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>字符串Hash题目<a href="https://blog.csdn.net/chaiwenjun000/article/details/71079819" target="_blank" rel="noopener">汇总</a></p><h2 id="HDU"><a href="#HDU" class="headerlink" title="HDU"></a>HDU</h2><p>关于BKDRHash的介绍较为详细的文章可以点击<a href="https://blog.csdn.net/wanglx_/article/details/40400693" target="_blank" rel="noopener">文章1</a> 以及<a href="https://www.cnblogs.com/ldy-miss/p/6099454.html" target="_blank" rel="noopener">文章2</a></p><p>一个小tip是, bkdrhash最好<strong><em>return (h &amp; 0x7FFFFFFF)</em></strong>，如果模散列表，当长度小的时候容易造成冲突，可以采用开放地址或者拉链法解决。但是如果直接自然溢出，冲突数较小，这种方法似乎和map更搭。</p><table><thead><tr><th>序号</th><th>题目名</th><th>所属比赛</th><th>算法</th><th>做出/补题</th><th>做题时间</th></tr></thead><tbody><tr><td><center> 1 </center></td><td><center> <a href="/2018/05/17/ACM-Training/hdu1880.cpp" title="1880.魔咒词典">1880.魔咒词典</a></center></td><td><center>类题训练</center></td><td><center>字符串BKDRHash</center></td><td><center> √ </center></td><td><center>2018/5/25 </center></td></tr><tr><td><center> 2 </center></td><td><center> <a href="/2018/05/17/ACM-Training/hdu6287.cpp" title="6287.口算训练">6287.口算训练</a></center></td><td><center>CCPC2018女生赛</center></td><td><center>数学</center></td><td><center> √ </center></td><td><center>2018/5/29 </center></td></tr></tbody></table><p><a href="http://www.360doc.com/content/14/0721/09/16319846_395862328.shtml" target="_blank" rel="noopener">Hash冲突处理</a></p><p><a href="https://blog.csdn.net/u013806583/article/details/52643541?locationNum=2&amp;fps=1" target="_blank" rel="noopener">ASL计算方法</a></p><h2 id="POJ"><a href="#POJ" class="headerlink" title="POJ"></a>POJ</h2><table><thead><tr><th>序号</th><th>题目名</th><th>所属比赛</th><th>算法</th><th>做出/补题</th><th>做题时间</th></tr></thead><tbody><tr><td><center> 1 </center></td><td><center> <a href="/2018/05/17/ACM-Training/poj3274.cpp" title="3274.Gold Balanced Lineup">3274.Gold Balanced Lineup</a></center></td><td><center>类题训练</center></td><td><center>拉链法Hash</center></td><td><center> √ </center></td><td><center>2018/5/29 </center></td></tr></tbody></table><h1 id="ACM-ICPC徐州邀请赛"><a href="#ACM-ICPC徐州邀请赛" class="headerlink" title="ACM-ICPC徐州邀请赛"></a>ACM-ICPC徐州邀请赛</h1><p>详情见:<br><a href="/2018/06/03/18-6-icpcjsxz/" title="徐州邀请赛总结">徐州邀请赛总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题解在题目名链接的代码中查看&lt;/p&gt;
&lt;h1 id=&quot;Codeforces&quot;&gt;&lt;a href=&quot;#Codeforces&quot; class=&quot;headerlink&quot; title=&quot;Codeforces&quot;&gt;&lt;/a&gt;Codeforces&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr
      
    
    </summary>
    
      <category term="ACM" scheme="http://www.zjdx1998.ml/categories/ACM/"/>
    
    
      <category term="ACM" scheme="http://www.zjdx1998.ml/tags/ACM/"/>
    
      <category term="数学" scheme="http://www.zjdx1998.ml/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="dp" scheme="http://www.zjdx1998.ml/tags/dp/"/>
    
      <category term="模拟" scheme="http://www.zjdx1998.ml/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="http://www.zjdx1998.ml/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分" scheme="http://www.zjdx1998.ml/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="树状数组" scheme="http://www.zjdx1998.ml/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="Hash" scheme="http://www.zjdx1998.ml/tags/Hash/"/>
    
      <category term="字符串" scheme="http://www.zjdx1998.ml/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>敲理妈，累死我了</title>
    <link href="http://www.zjdx1998.ml/2018/05/06/hello-world/"/>
    <id>http://www.zjdx1998.ml/2018/05/06/hello-world/</id>
    <published>2018-05-05T18:07:35.418Z</published>
    <updated>2018-05-12T02:06:16.817Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2018年5月6日3.45分，时隔7年时间我终于用上自己的博客了…</p><p>不过这次是亲手一步步搭的，以后会不定期更新…</p><p>谢谢大家的支持！</p><h2 id="本博客的用处"><a href="#本博客的用处" class="headerlink" title="本博客的用处"></a>本博客的用处</h2><pre><code>技术博客生活随笔</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是北京时间2018年5月6日3.45分，时隔7年时间我终于用上自己的博客了…&lt;/p&gt;
&lt;p&gt;不过这次是亲手一步步搭的，以后会不定期更新…&lt;/p&gt;
&lt;p&gt;谢谢大家的支持！&lt;/p&gt;
&lt;h2 id=&quot;本博客的用处&quot;&gt;&lt;a href=&quot;#本博客的用处&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
</feed>
